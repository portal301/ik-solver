/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004c generated on 2025-11-18 15:37:20.857081
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004c);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>


#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif
#else
#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf std::isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER


#ifdef _MSC_VER
// Modern MSVC with C++17: use standard math functions (no compat macros needed)
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.03) // 5D IK has some crazy degenerate cases, but can rely on jacobian refinment to make better, just need good starting point
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

template <typename T> struct ComplexLess
{
    bool operator()(const complex<T>& lhs, const complex<T>& rhs) const
    {
        if (real(lhs) < real(rhs)) {
            return true;
        }
        if (real(lhs) > real(rhs)) {
            return false;
        }
        return imag(lhs) < imag(rhs);
    }
};

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70,x71,x72,x73,x74,x75,x76,x77,x78,x79;
x0=IKsin(j[0]);
x1=IKsin(j[1]);
x2=IKsin(j[2]);
x3=IKcos(j[1]);
x4=IKcos(j[2]);
x5=IKcos(j[3]);
x6=IKcos(j[0]);
x7=IKsin(j[3]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=((0.25)*x6);
x13=((0.433012701892219)*x2);
x14=((0.07361343)*x8);
x15=((0.6212489)*x1);
x16=((0.433012701892219)*x5);
x17=((1.0)*x8);
x18=((0.123406714783394)*x5);
x19=((0.5)*x2);
x20=((0.25)*x2);
x21=((0.125)*x4);
x22=((0.866025403784439)*x8);
x23=((1.0)*x9);
x24=((0.5)*x5);
x25=((0.75)*x5);
x26=((1.0)*x7);
x27=((0.07361343)*x9);
x28=((0.866025403784439)*x9);
x29=((0.866025403784439)*x6);
x30=((0.125)*x2);
x31=((0.5)*x4);
x32=(x0*x1);
x33=(x3*x4);
x34=(x6*x7);
x35=(x0*x7);
x36=((-1.0)*x7);
x37=(x7*x8);
x38=(x3*x6);
x39=(x1*x2);
x40=((-0.433012701892219)*x6);
x41=(x1*x6);
x42=(x0*x3);
x43=(x1*x4);
x44=(x5*x6);
x45=(x0*x5);
x46=((-0.5)*x7);
x47=(x2*x3);
x48=((0.433012701892219)*x43);
x49=(x13*x3);
x50=(x13*x32);
x51=((0.433012701892219)*x0*x33);
x52=(x39+x33);
x53=(((x1*x19))+((x3*x31)));
x54=((((-1.0)*x33))+(((-1.0)*x39)));
x55=((((0.866025403784439)*x33))+(((0.866025403784439)*x39)));
x56=((((0.433012701892219)*x33))+((x1*x13)));
x57=(((x2*x42))+(((-1.0)*x32*x4)));
x58=((((-1.0)*x2*x38))+((x4*x41)));
x59=(x52*x7*x9);
x60=(x5*x53);
x61=(x5*x55);
x62=(((x19*x42))+(((-1.0)*x31*x32)));
x63=((((-1.0)*x19*x38))+((x31*x41)));
x64=(x5*x57);
x65=(x57*x7);
x66=(x58*x7);
x67=(x5*x62);
x68=(x25*x57);
x69=(x24*x62);
x70=(x44+x65);
x71=(x45+x66);
x72=(x60+(((0.866025403784439)*x47))+(((-0.866025403784439)*x43)));
x73=(x72*x9);
x74=(x51+x50+x68);
x75=((((-0.866025403784439)*x0*x33))+(((-0.5)*x34))+x67+(((-0.866025403784439)*x2*x32)));
x76=((((-0.5)*x35))+((x5*x63))+((x29*((x39+x33)))));
x77=(x76*x8);
x78=((((-1.0)*x49))+(((-1.0)*x37*x53))+((x9*(((((-1.0)*x48))+((x24*x53))+x49))))+x48+(((0.866025403784439)*x61)));
x79=(((x9*(((((-0.25)*x35))+(((0.433012701892219)*x33*x6))+((x24*x63))+((x13*x41))))))+((x39*x40))+((x25*x58))+(((-0.75)*x35))+((x8*(((((-0.5)*x45))+((x46*x58))))))+((x33*x40)));
eerot[0]=(((x10*((((x70*x9))+((x8*(((((-0.866025403784439)*x0*x33))+(((-0.5)*x34))+x67+(((-0.866025403784439)*x2*x32))))))))))+((x11*((((x9*(((((-1.0)*x12*x7))+x69+(((-1.0)*x50))+(((-1.0)*x51))))))+x74+((x8*(((((-1.0)*x24*x6))+(((-0.5)*x65))))))+(((-0.75)*x34)))))));
IkReal x80=((1.0)*x57);
eerot[1]=((((-1.0)*x16*x80))+(((0.433012701892219)*x34))+(((-1.0)*x20*x32))+((x28*x75))+(((-0.25)*x0*x33))+((x22*(((((-1.0)*x44))+(((-1.0)*x26*x80)))))));
eerot[2]=(((x11*(((((-1.0)*x23*x70))+(((-1.0)*x17*x75))))))+((x10*((((x9*(((((-0.433012701892219)*x0*x33))+(((-0.25)*x34))+(((-0.433012701892219)*x2*x32))+x69))))+x74+((x8*(((((-0.5)*x44))+((x46*x57))))))+(((-0.75)*x34)))))));
eetrans[0]=((((-1.0)*x18*x57))+((x14*(((((-1.0)*x44))+((x36*x57))))))+(((-0.135)*x0))+((x27*x75))+(((-1.0)*x21*x32))+((x30*x42))+(((-1.0)*x0*x15*x2))+(((-0.6)*x32))+(((-0.6212489)*x0*x33))+(((0.123406714783394)*x34)));
eerot[3]=(((x10*((((x71*x9))+x77))))+((x11*x79)));
IkReal x81=((1.0)*x58);
eerot[4]=((((-1.0)*x16*x81))+(((0.433012701892219)*x35))+((x28*x76))+((x22*(((((-1.0)*x45))+(((-1.0)*x26*x81))))))+((x12*x39))+((x12*x33)));
eerot[5]=(((x10*x79))+((x11*(((((-1.0)*x23*x71))+(((-1.0)*x17*x76)))))));
eetrans[1]=((((-1.0)*x30*x38))+(((-1.0)*x18*x58))+((x14*(((((-1.0)*x45))+((x36*x58))))))+(((0.6)*x41))+((x21*x41))+((x27*x76))+(((0.135)*x6))+(((0.6212489)*x33*x6))+((x15*x2*x6))+(((0.123406714783394)*x35)));
eerot[6]=(((x10*((((x72*x8))+x59))))+((x11*x78)));
eerot[7]=((((-0.25)*x43))+(((-1.0)*x5*x56))+((x28*x72))+((x22*x54*x7))+((x20*x3)));
eerot[8]=(((x10*x78))+((x11*(((((-1.0)*x23*x52*x7))+(((-1.0)*x17*x72)))))));
eetrans[2]=((0.45)+((x14*x54*x7))+((x21*x3))+(((0.6)*x3))+(((0.6212489)*x47))+((x27*x72))+((x1*x30))+(((-1.0)*x15*x4))+(((-0.135000000439708)*x5*x56))+(((-0.0749977997801462)*x61)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API const int* GetFreeIndices() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,tj0,j0mul,j1,cj1,sj1,htj1,tj1,j1mul,j2,cj2,sj2,htj2,tj2,j2mul,j3,cj3,sj3,htj3,tj3,j3mul,j4,cj4,sj4,htj4,tj4,j4mul,j5,cj5,sj5,htj5,tj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r02;
new_r02=((-1.0)*r01);
new_px=((((-0.135000000439708)*r01))+px);
new_r10=r10;
new_r11=r12;
new_r12=((-1.0)*r11);
new_py=((((-0.135000000439708)*r11))+py);
new_r20=r20;
new_r21=r22;
new_r22=((-1.0)*r21);
new_pz=((-0.45)+(((-0.135000000439708)*r21))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x82=((1.0)*px);
IkReal x83=((1.0)*pz);
IkReal x84=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x84))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x83)));
rxp0_2=((((-1.0)*r10*x82))+((py*r00)));
rxp1_0=((((-1.0)*r21*x84))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x83)));
rxp1_2=((((-1.0)*r11*x82))+((py*r01)));
rxp2_0=((((-1.0)*r22*x84))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x83))+((px*r22)));
rxp2_2=((((-1.0)*r12*x82))+((py*r02)));
IkReal op[72], zeror[48];
int numroots;;
IkReal x85=((((-0.0865999997833942)*r20))+rxp2_2);
IkReal x86=((0.173199999566788)*r21);
IkReal x87=((0.0865999997833942)*r20);
IkReal x88=((0.27)*py);
IkReal x89=((0.173199999566788)*npy);
IkReal x90=((0.1485)*r12);
IkReal x91=((0.0233819999415164)*r11);
IkReal x92=((0.03375)*r22);
IkReal x93=((1.1)*npz);
IkReal x94=((1.0)*pp);
IkReal x95=((0.0216499999458485)*r00);
IkReal x96=((0.25)*rxp2_0);
IkReal x97=((0.0233819999415164)*r01);
IkReal x98=((0.1485)*r02);
IkReal x99=((0.27)*px);
IkReal x100=((0.0216499999458485)*r10);
IkReal x101=((0.25)*rxp2_1);
IkReal x102=((0.0432999998916971)*r01);
IkReal x103=((0.0467639998830329)*r10);
IkReal x104=((0.346399999133577)*npx);
IkReal x105=((3.46410161513775)*rxp1_2);
IkReal x106=((1.73205080756888)*rxp0_2);
IkReal x107=((0.149995599560293)*r22);
IkReal x108=((0.0374988998900731)*r02);
IkReal x109=((0.257209544923978)*r10);
IkReal x110=((0.433012701892219)*rxp0_0);
IkReal x111=((1.90525588832577)*npx);
IkReal x112=((0.0584567147554496)*r20);
IkReal x113=((0.0374988998900731)*r12);
IkReal x114=((0.433012701892219)*rxp0_1);
IkReal x115=((0.257209544923978)*r00);
IkReal x116=((0.866025403784439)*rxp1_0);
IkReal x117=((0.514419089847956)*r11);
IkReal x118=((0.116913429510899)*r21);
IkReal x119=((3.81051177665153)*npy);
IkReal x120=((0.866025403784439)*rxp1_2);
IkReal x121=((0.0432999998916971)*r20);
IkReal x122=((0.5)*rxp2_2);
IkReal x123=((0.55)*npz);
IkReal x124=((0.125)*rxp2_0);
IkReal x125=((1.12582794372967)*npy);
IkReal x126=((0.0292283573777248)*r21);
IkReal x127=((0.21650635094611)*rxp1_0);
IkReal x128=((0.016875)*r22);
IkReal x129=((0.0108249999729243)*r00);
IkReal x130=((0.151986772403506)*r11);
IkReal x131=((0.07425)*r12);
IkReal x132=((0.125)*rxp2_1);
IkReal x133=((0.151986772403506)*r01);
IkReal x134=((0.21650635094611)*rxp1_1);
IkReal x135=((0.07425)*r02);
IkReal x136=((0.0108249999729243)*r10);
IkReal x137=((2.25165588745934)*npx);
IkReal x138=((0.303973544807011)*r10);
IkReal x139=((0.0216499999458485)*r01);
IkReal x140=(rxp2_2+x87);
IkReal x141=((((-1.0)*x107))+x106);
IkReal x142=((((-0.0865999997833942)*r21))+x106);
IkReal x143=((((-0.0432999998916971)*r11))+(((-0.0467639998830329)*r00)));
IkReal x144=((((-1.0)*x107))+(((-1.0)*x106)));
IkReal x145=((((-0.866025403784439)*rxp1_1))+(((-0.514419089847956)*r01)));
IkReal x146=(x131+x94);
IkReal x147=(x120+x121);
IkReal x148=(x89+x96);
IkReal x149=(x126+x125);
IkReal x150=(x127+x129);
IkReal x151=(x139+x138);
IkReal x152=(x137+x112);
IkReal x153=(x112+x111);
IkReal x154=(x119+x118);
IkReal x155=(x88+x90);
IkReal x156=(x124+x88);
IkReal x157=(x108+x109);
IkReal x158=(x110+x108);
IkReal x159=(x115+x114);
IkReal x160=(x91+x95);
IkReal x161=(x135+x132);
IkReal x162=((((-1.0)*x159))+x113);
IkReal x163=((((-1.0)*x122))+x147);
IkReal x164=((((-1.0)*x114))+(((0.0216499999458485)*r11))+(((-0.303973544807011)*r00)));
IkReal x165=((0.0161504400375161)+x160);
IkReal x166=((-0.0663471397206447)+x123+x128);
IkReal x167=(x159+x113);
IkReal x168=((((-1.0)*x147))+(((-1.0)*x122)));
IkReal x169=(x93+x92+x94);
IkReal x170=(x156+x130);
IkReal x171=(x134+x136+x133);
IkReal x172=(x101+x99+x98);
IkReal x173=(x166+x131);
IkReal x174=((((-1.0)*x172))+x100+(((-1.0)*x97)));
IkReal x175=((((-1.0)*x172))+(((-1.0)*x100))+x97);
IkReal x176=((((-1.0)*x171))+x161+(((-1.0)*x99)));
IkReal x177=(x171+x161+(((-1.0)*x99)));
op[0]=x85;
op[1]=x85;
op[2]=x86;
op[3]=x86;
op[4]=x140;
op[5]=x140;
op[6]=((((-1.0)*x148))+(((-1.0)*x169))+x165+x155);
op[7]=x174;
op[8]=((((-1.0)*x104))+(((-1.0)*x102))+x103);
op[9]=x143;
op[10]=((0.0161504400375161)+(((-1.0)*x169))+(((-1.0)*x160))+x155+x89+(((-1.0)*x96)));
op[11]=x175;
op[12]=x174;
op[13]=((0.0161504400375161)+(((-1.0)*x155))+(((-1.0)*x169))+(((-1.0)*x160))+x96+(((-1.0)*x89)));
op[14]=x143;
op[15]=((((-1.0)*x104))+(((-1.0)*x103))+x102);
op[16]=x175;
op[17]=((((-1.0)*x155))+(((-1.0)*x169))+x165+x148);
op[18]=0;
op[19]=x85;
op[20]=0;
op[21]=x86;
op[22]=0;
op[23]=x140;
op[24]=x144;
op[25]=x144;
op[26]=x105;
op[27]=x105;
op[28]=x141;
op[29]=x141;
op[30]=((((-1.0)*x109))+x153+x158);
op[31]=x167;
op[32]=((((-1.0)*x154))+(((-1.0)*x116))+x117);
op[33]=x145;
op[34]=((((-1.0)*x153))+(((-1.0)*x110))+x157);
op[35]=x162;
op[36]=x167;
op[37]=((((-1.0)*x158))+x153+x109);
op[38]=x145;
op[39]=((((-1.0)*x154))+(((-1.0)*x117))+x116);
op[40]=x162;
op[41]=((((-1.0)*x157))+(((-1.0)*x153))+x110);
op[42]=0;
op[43]=x144;
op[44]=0;
op[45]=x105;
op[46]=0;
op[47]=x141;
op[48]=x163;
op[49]=x163;
op[50]=x142;
op[51]=x142;
op[52]=x168;
op[53]=x168;
op[54]=((((-1.0)*x149))+(((-1.0)*x146))+(((-1.0)*x150))+x170+x166);
op[55]=x176;
op[56]=((((-1.0)*x152))+(((-1.0)*x110))+x151);
op[57]=x164;
op[58]=((((-1.0)*x146))+x166+x156+x150+x149+(((-1.0)*x130)));
op[59]=x177;
op[60]=x176;
op[61]=((((-1.0)*x149))+(((-1.0)*x170))+x173+x150+(((-1.0)*x94)));
op[62]=x164;
op[63]=((((-1.0)*x151))+(((-1.0)*x152))+x110);
op[64]=x177;
op[65]=((((-1.0)*x150))+(((-1.0)*x156))+x173+x149+x130+(((-1.0)*x94)));
op[66]=0;
op[67]=x163;
op[68]=0;
op[69]=x142;
op[70]=0;
op[71]=x168;
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j4array[16], cj4array[16], sj4array[16], j5array[16], cj5array[16], sj5array[16], j0array[16], cj0array[16], sj0array[16];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ij4 += 3)
{
IkReal htj4 = zeror[ij4+0], htj5 = zeror[ij4+1], htj0 = zeror[ij4+2];
if(isnan(htj4)||isnan(htj5)||isnan(htj0)){
continue;
}
j4array[numsolutions]=((2.0)*(atan(htj4)));
j5array[numsolutions]=((2.0)*(atan(htj5)));
j0array[numsolutions]=((2.0)*(atan(htj0)));
if(isinf(htj4)){
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
}
else{
IkReal x178=htj4*htj4;
CheckValue<IkReal> x179=IKPowWithIntegerCheck(((1.0)+x178),-1);
if(!x179.valid){
continue;
}
cj4array[numsolutions]=((x179.value)*(((1.0)+(((-1.0)*x178)))));
CheckValue<IkReal> x180=IKPowWithIntegerCheck(((1.0)+(htj4*htj4)),-1);
if(!x180.valid){
continue;
}
sj4array[numsolutions]=((2.0)*htj4*(x180.value));
}
if(isinf(htj5)){
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
}
else{
IkReal x181=htj5*htj5;
CheckValue<IkReal> x182=IKPowWithIntegerCheck(((1.0)+x181),-1);
if(!x182.valid){
continue;
}
cj5array[numsolutions]=((x182.value)*(((1.0)+(((-1.0)*x181)))));
CheckValue<IkReal> x183=IKPowWithIntegerCheck(((1.0)+(htj5*htj5)),-1);
if(!x183.valid){
continue;
}
sj5array[numsolutions]=((2.0)*htj5*(x183.value));
}
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x184=htj0*htj0;
CheckValue<IkReal> x185=IKPowWithIntegerCheck(((1.0)+x184),-1);
if(!x185.valid){
continue;
}
cj0array[numsolutions]=((x185.value)*(((1.0)+(((-1.0)*x184)))));
CheckValue<IkReal> x186=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x186.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x186.value));
}
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j4valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj4 = 16;
_nj5 = 1;
_nj0 = 1;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
_ij5[0] = 0; _ij5[1] = -1;
_ij0[0] = 0; _ij0[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( !j4valid[iij4] ) { continue; }
if( IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj5array[ij4]-cj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij4]-sj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj0array[ij4]-cj0array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij4]-sj0array[iij4]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j4valid[iij4]=false; _ij4[1] = iij4; _ij5[1] = 0; _ij0[1] = 0;  break; 
}
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

    j5 = j5array[ij4]; cj5 = cj5array[ij4]; sj5 = sj5array[ij4];

    j0 = j0array[ij4]; cj0 = cj0array[ij4]; sj0 = sj0array[ij4];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+3, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+5, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+4, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+7, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+6, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+8, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3eval[2];
IkReal x187=((2.0)*sj4);
IkReal x188=(r11*sj5);
IkReal x189=(cj5*r10);
IkReal x190=((0.866025403784439)*sj4);
IkReal x191=(cj4*r12);
IkReal x192=(r10*sj5);
IkReal x193=(cj5*r11);
IkReal x194=((1.0)*cj4);
IkReal x195=((0.433012701892219)*x193);
j3eval[0]=((((-1.0)*x192*x194))+((x187*x188))+(((-1.0)*x187*x189))+x193+x192+(((1.73205080756888)*x191))+(((0.577350269189626)*r12))+(((-1.0)*x193*x194)));
j3eval[1]=IKsign(((((-1.0)*x189*x190))+(((0.25)*r12))+(((-1.0)*cj4*x195))+((x188*x190))+x195+(((0.75)*x191))+(((-0.433012701892219)*cj4*x192))+(((0.433012701892219)*x192))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x196=((0.433012701892219)*cj4);
IkReal x197=(r00*sj5);
IkReal x198=(cj5*r01);
IkReal x199=(cj4*r02);
IkReal x200=((1.73205080756888)*cj4);
IkReal x201=(cj5*r00*sj4);
IkReal x202=(r01*sj4*sj5);
j3eval[0]=((((-3.0)*x199))+((x198*x200))+(((-1.0)*r02))+((x197*x200))+(((3.46410161513775)*x201))+(((-3.46410161513775)*x202))+(((-1.73205080756888)*x197))+(((-1.73205080756888)*x198)));
j3eval[1]=IKsign(((((-0.433012701892219)*x197))+(((-0.433012701892219)*x198))+(((-0.866025403784439)*x202))+(((-0.25)*r02))+((x196*x197))+((x196*x198))+(((0.866025403784439)*x201))+(((-0.75)*x199))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x203=(r20*sj5);
IkReal x204=((1.73205080756888)*cj4);
IkReal x205=(cj4*r22);
IkReal x206=(cj5*r21);
IkReal x207=((0.433012701892219)*cj4);
IkReal x208=(r21*sj4*sj5);
IkReal x209=(cj5*r20*sj4);
j3eval[0]=((((-3.0)*x205))+(((-1.73205080756888)*x203))+(((-1.73205080756888)*x206))+((x204*x206))+(((3.46410161513775)*x209))+(((-3.46410161513775)*x208))+(((-1.0)*r22))+((x203*x204)));
j3eval[1]=IKsign(((((-0.433012701892219)*x203))+(((-0.433012701892219)*x206))+(((-0.866025403784439)*x208))+(((0.866025403784439)*x209))+(((-0.75)*x205))+(((-0.25)*r22))+((x203*x207))+((x206*x207))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x210=((0.5)*sj4);
IkReal x211=(sj0*sj5);
IkReal x212=(cj0*r10);
IkReal x213=(cj0*r11);
IkReal x214=((1.0)*cj4);
IkReal x215=((0.433012701892219)*cj4);
IkReal x216=(r02*sj0);
IkReal x217=((0.25)*cj4);
IkReal x218=((0.866025403784439)*sj4);
IkReal x219=(cj5*r01*sj0);
IkReal x220=((0.433012701892219)*cj0*r12);
IkReal x221=(cj5*r00*sj0);
CheckValue<IkReal> x222=IKPowWithIntegerCheck(IKsign((((r22*(((-0.25)+(((-0.75)*cj4))))))+((r20*((((cj5*x218))+((sj5*x215))+(((-0.433012701892219)*sj5))))))+((r21*(((((-1.0)*sj5*x218))+((cj5*x215))+(((-0.433012701892219)*cj5)))))))),-1);
if(!x222.valid){
continue;
}
CheckValue<IkReal> x223 = IKatan2WithCheck(IkReal(((((-1.0)*cj0*r12*x218))+(((-1.0)*r01*x211*x214))+(((-1.0)*cj5*x212*x214))+((sj5*x210*x212))+((x216*x218))+((cj4*sj5*x213))+((cj5*x210*x213))+(((-1.0)*r00*x210*x211))+(((-1.0)*x210*x219))+((cj4*x221)))),IkReal((((x210*x221))+(((-1.0)*sj5*x212*x217))+(((-0.75)*sj5*x212))+(((0.75)*x219))+((sj5*x210*x213))+(((-1.0)*r01*x210*x211))+((r00*x211*x217))+(((-1.0)*cj5*x210*x212))+(((0.433012701892219)*x216))+(((-1.0)*cj5*x213*x217))+((cj0*r12*x215))+(((0.75)*r00*x211))+((x217*x219))+(((-0.75)*cj5*x213))+(((-1.0)*x220))+(((-1.0)*x215*x216)))),IKFAST_ATAN2_MAGTHRESH);
if(!x223.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x222.value)))+(x223.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
tj3 = IKtan(j3);
{
IkReal evalcond[3];
IkReal x224=IKsin(j3);
IkReal x225=IKcos(j3);
IkReal x226=((0.5)*sj4);
IkReal x227=((1.0)*cj4);
IkReal x228=((0.25)*cj4);
IkReal x229=((0.433012701892219)*x224);
IkReal x230=(cj5*x224);
IkReal x231=(sj5*x224);
IkReal x232=(sj5*x225);
IkReal x233=(cj5*x225);
IkReal x234=((0.866025403784439)*sj4*x225);
evalcond[0]=(((cj4*r21*x232))+(((-1.0)*r22*x234))+((r21*x226*x233))+((r20*x226*x230))+((r20*x226*x232))+((r21*x228*x230))+(((-1.0)*r21*x226*x231))+(((0.75)*r20*x231))+(((-1.0)*cj4*r22*x229))+((r20*x228*x231))+((r22*x229))+(((0.75)*r21*x230))+(((-1.0)*r20*x227*x233)));
evalcond[1]=(((cj4*r01*x232))+((r00*x228*x231))+((r01*x226*x233))+cj0+(((-1.0)*r02*x234))+((r01*x228*x230))+(((-1.0)*cj4*r02*x229))+(((-1.0)*r01*x226*x231))+(((-1.0)*r00*x227*x233))+(((0.75)*r01*x230))+((r02*x229))+(((0.75)*r00*x231))+((r00*x226*x232))+((r00*x226*x230)));
evalcond[2]=((((-1.0)*r12*x234))+(((0.75)*r11*x230))+(((-1.0)*cj4*r12*x229))+sj0+(((-1.0)*r10*x227*x233))+((cj4*r11*x232))+(((0.75)*r10*x231))+((r12*x229))+((r11*x226*x233))+((r11*x228*x230))+((r10*x226*x230))+((r10*x226*x232))+((r10*x228*x231))+(((-1.0)*r11*x226*x231)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[8+1], zeror[8];
int numroots;
IkReal x235=((1.0)*px);
IkReal x236=((0.0865999997833942)*sj5);
IkReal x237=((0.0865999997833942)*cj5);
IkReal x238=(r01*x237);
IkReal x239=(r00*x236);
IkReal x240=(((r20*x236))+(((1.0)*pz))+((r21*x237)));
IkReal x241=((0.725)+(((-1.0)*x240)));
IkReal x242=((0.475)+(((-1.0)*x240)));
IkReal x243=((-0.725)+(((-1.0)*x240)));
IkReal x244=((-0.475)+(((-1.0)*x240)));
IkReal x245=(x238+x239+x235);
IkReal x246=((((0.415)*sj0))+(((-1.0)*x245)));
IkReal x247=((((-0.685)*sj0))+(((-1.0)*x245)));
IkReal gconst0=x241;
IkReal gconst1=x242;
IkReal gconst2=x247;
IkReal gconst3=x246;
IkReal gconst4=x241;
IkReal gconst5=x242;
IkReal gconst6=x247;
IkReal gconst7=x246;
IkReal gconst8=x243;
IkReal gconst9=x244;
IkReal gconst10=x246;
IkReal gconst11=x247;
IkReal gconst12=x243;
IkReal gconst13=x244;
IkReal gconst14=x246;
IkReal gconst15=x247;
IkReal x248=sj0*sj0;
IkReal x249=(gconst0*gconst11);
IkReal x250=(gconst5*gconst6);
IkReal x251=((1.0)*gconst12);
IkReal x252=(gconst0*gconst5);
IkReal x253=((1.045)*sj0);
IkReal x254=(gconst14*gconst8);
IkReal x255=((0.0625)*gconst4);
IkReal x256=(gconst13*gconst14);
IkReal x257=((1.21)*gconst7);
IkReal x258=(gconst13*sj0);
IkReal x259=(gconst10*gconst9);
IkReal x260=(gconst0*gconst7);
IkReal x261=(gconst3*gconst4);
IkReal x262=((1.4795)*sj0);
IkReal x263=(gconst11*gconst8);
IkReal x264=(gconst2*gconst5);
IkReal x265=((1.595)*sj0);
IkReal x266=(gconst11*sj0);
IkReal x267=((1.0)*gconst1);
IkReal x268=((1.21)*gconst11);
IkReal x269=(gconst15*gconst4);
IkReal x270=((0.275)*sj0);
IkReal x271=((2.64)*sj0);
IkReal x272=(gconst11*gconst14);
IkReal x273=(gconst9*sj0);
IkReal x274=((1.0)*gconst7);
IkReal x275=(gconst10*gconst15);
IkReal x276=((1.1)*gconst12);
IkReal x277=((0.95)*sj0);
IkReal x278=((1.1)*gconst3);
IkReal x279=(gconst3*gconst8);
IkReal x280=(gconst15*gconst9);
IkReal x281=((1.1)*gconst7);
IkReal x282=(gconst1*gconst2);
IkReal x283=(gconst1*gconst7);
IkReal x284=(gconst3*gconst6);
IkReal x285=((1.1)*gconst11);
IkReal x286=((0.0625)*gconst12);
IkReal x287=(gconst3*sj0);
IkReal x288=(gconst12*gconst8);
IkReal x289=(gconst2*gconst9);
IkReal x290=(gconst0*gconst3);
IkReal x291=(gconst13*gconst6);
IkReal x292=((1.21)*gconst14);
IkReal x293=(gconst2*gconst4);
IkReal x294=((1.1)*gconst15);
IkReal x295=(gconst12*gconst15);
IkReal x296=((1.452)*sj0);
IkReal x297=(gconst4*gconst7);
IkReal x298=(gconst0*gconst6);
IkReal x299=(gconst12*gconst7);
IkReal x300=(gconst6*x268);
IkReal x301=(gconst3*x292);
IkReal x302=((1.7424)*x248);
IkReal x303=((1.3775)*x248);
IkReal x304=(gconst1*x248);
IkReal x305=(gconst1*gconst6*sj0);
IkReal x306=((1.45)*gconst1*sj0);
IkReal x307=(gconst9*x248);
IkReal x308=((3.39025)*x248);
IkReal x309=((0.9025)*x248);
IkReal x310=((0.33)*x248);
IkReal x311=(gconst12*gconst3*x270);
IkReal x312=(gconst1*gconst14*x270);
IkReal x313=((0.275)*gconst4*x266);
IkReal x314=(gconst6*gconst9*x270);
IkReal x315=(x255*x307);
IkReal x316=(x286*x304);
IkReal x317=(x314+x311+x313+x312);
IkReal x318=(x302+x300+x301+x315+x316);
op[0]=((((-1.0)*x256*x259))+(((-1.0)*gconst15*x251*x263))+(((-1.0)*x286*x307))+(((-1.0)*gconst14*x268))+((gconst14*gconst9*x270))+((x259*x295))+((gconst11*gconst13*x254))+(((0.275)*gconst12*x266)));
op[1]=(((x263*x294))+(((-1.0)*gconst12*x259*x277))+(((-1.0)*gconst12*x310))+((gconst12*x263*x277))+(((-0.95)*x254*x258))+((x275*x276))+(((-0.33)*x307))+(((2.295)*gconst14*x273))+(((-1.1)*gconst14*x259))+(((-1.1)*gconst10*x256))+(((-1.45)*x258*x263))+(((1.1)*x272))+(((1.45)*x256*x273))+(((1.45)*x258*x259))+(((1.452)*x266))+(((2.295)*gconst12*x266))+((x254*x285))+(((-1.0)*x276*x307))+((gconst11*gconst15*x276))+(((-1.0)*x259*x294))+(((-1.45)*x273*x295))+(((-1.0)*x256*x285))+((gconst15*x277*x288))+((gconst14*x296)));
op[2]=((((-1.0)*gconst15*x251*x279))+((x263*x291))+(((-1.0)*x271*x295))+((gconst13*gconst3*x254))+(((-1.0)*x263*x271))+(((-1.0)*gconst7*x251*x263))+(((-1.0)*x256*x289))+((gconst1*gconst12*x275))+((x249*x256))+((gconst14*x262))+(((-1.0)*gconst10*x256*x267))+((x259*x271))+((x259*x269))+(((-1.0)*gconst10*gconst12*x253))+(((-4.1195)*x266))+(((-1.0)*x288*x309))+(((-2.11775)*x307))+x317+((gconst11*gconst5*x254))+(((1.595)*gconst10*x258))+(((-1.0)*gconst15*x268))+(((-1.0)*gconst10*x292))+((x259*x299))+(((-1.0)*gconst15*x249*x251))+(((-1.0)*x318))+((gconst12*gconst2*x280))+(((-2.695)*gconst12*x266))+(((1.595)*gconst11*x258))+(((-2.1025)*gconst13*x307))+(((-1.0)*x263*x269))+(((-3.3375)*gconst12*x307))+(((-1.21)*x275))+((x256*x271))+((x265*x280))+(((-1.0)*x253*x254))+(((-1.0)*gconst14*gconst5*x259))+(((-1.0)*x259*x291))+(((-1.0)*gconst12*x308))+(((-1.0)*gconst15*gconst8*x253))+((gconst13*gconst8*x303))+(((-0.055)*gconst14*x273))+(((0.96)*x272)));
op[3]=((((-0.95)*gconst0*gconst13*gconst14*sj0))+(((1.584)*(sj0*sj0)))+(((2.295)*gconst6*gconst9*sj0))+(((-1.45)*gconst0*gconst11*gconst13*sj0))+(((1.1)*gconst12*gconst15*gconst3))+(((1.1)*gconst12*gconst15*gconst2))+(((-1.45)*gconst11*gconst5*gconst8*sj0))+(((-0.95)*gconst1*gconst10*gconst12*sj0))+(((-1.1)*gconst13*gconst14*gconst2))+(((-1.1)*gconst13*gconst14*gconst3))+(((2.295)*gconst11*gconst4*sj0))+(((2.904)*gconst10*sj0))+(((1.1)*gconst11*gconst6*gconst8))+(((-1.1)*gconst11*gconst13*gconst6))+(((2.508)*gconst8*(sj0*sj0)))+(((-1.1)*gconst10*gconst6*gconst9))+(((-0.33)*gconst4*(sj0*sj0)))+(((0.95)*gconst11*gconst4*gconst8*sj0))+(((-1.45)*gconst1*gconst12*gconst15*sj0))+(((-1.1)*gconst14*gconst2*gconst9))+(((-2.295)*gconst14*gconst9*sj0))+(((1.1)*gconst11*gconst6))+(((-1.45)*gconst13*gconst3*gconst8*sj0))+(((0.95)*gconst15*gconst4*gconst8*sj0))+(((1.45)*gconst1*gconst13*gconst14*sj0))+(((-1.1)*gconst10*gconst14*gconst5))+(((0.95)*gconst12*gconst7*gconst8*sj0))+(((-1.45)*gconst12*gconst7*gconst9*sj0))+(((2.295)*gconst1*gconst14*sj0))+(((1.45)*gconst13*gconst6*gconst9*sj0))+(((-0.95)*gconst13*gconst6*gconst8*sj0))+(((1.45)*gconst10*gconst5*gconst9*sj0))+(((-0.9725)*gconst14*sj0))+(((1.1)*gconst0*gconst11*gconst14))+(((1.1)*gconst0*gconst11*gconst15))+(((-1.1)*gconst11*gconst14))+(((1.1)*gconst11*gconst12*gconst7))+(((1.1)*gconst11*gconst15*gconst4))+(((1.45)*gconst14*gconst5*gconst9*sj0))+(((3.751)*gconst9*(sj0*sj0)))+(((-1.1)*gconst4*gconst9*(sj0*sj0)))+(((-1.1)*gconst1*gconst12*(sj0*sj0)))+(((-1.45)*gconst15*gconst4*gconst9*sj0))+(((1.452)*gconst6*sj0))+(((-1.1)*gconst10*gconst13*gconst6))+(((-1.1)*gconst11*gconst14*gconst5))+(((0.95)*gconst12*gconst3*gconst8*sj0))+(((2.904)*gconst15*sj0))+(((-0.95)*gconst14*gconst5*gconst8*sj0))+(((1.45)*gconst13*gconst2*gconst9*sj0))+(((-0.95)*gconst10*gconst4*gconst9*sj0))+(((2.295)*gconst12*gconst3*sj0))+(((-1.1)*gconst10*gconst7*gconst9))+(((1.452)*gconst3*sj0))+(((1.1)*gconst10*gconst12*gconst7))+(((-0.33)*gconst1*(sj0*sj0)))+(((1.1)*gconst12*gconst9*(sj0*sj0)))+(((0.95)*gconst0*gconst11*gconst12*sj0))+(((1.5725)*gconst11*sj0))+(((1.1)*gconst10*gconst15*gconst4))+(((1.1)*gconst15*gconst3*gconst8))+(((0.95)*gconst0*gconst12*gconst15*sj0))+(((-1.111)*gconst12*(sj0*sj0)))+(((1.1)*gconst14*gconst3*gconst8))+(((-1.1)*gconst15*gconst2*gconst9))+(((1.1)*gconst14*gconst3))+(((-3.828)*gconst13*(sj0*sj0)))+(((-0.95)*gconst12*gconst2*gconst9*sj0))+(((1.45)*gconst1*gconst10*gconst13*sj0))+(((-2.295)*gconst11*gconst12*sj0))+(((1.1)*gconst11*gconst7*gconst8))+(((-1.1)*gconst1*gconst10*gconst14))+(((-1.1)*gconst1*gconst10*gconst15)));
op[4]=((((-1.0)*gconst0*gconst11*gconst12*gconst7))+(((-2.64)*gconst12*gconst7*sj0))+(((1.3775)*gconst5*gconst8*(sj0*sj0)))+((gconst1*gconst10*gconst12*gconst7))+(((0.275)*gconst3*gconst4*sj0))+(((1.4795)*gconst6*sj0))+(((1.595)*gconst7*gconst9*sj0))+(((0.96)*gconst11*gconst6))+(((-1.0)*gconst1*gconst10*gconst13*gconst6))+(((-2.1025)*gconst5*gconst9*(sj0*sj0)))+(((1.595)*gconst11*gconst5*sj0))+((gconst11*gconst5*gconst6*gconst8))+(((-0.0625)*gconst12*gconst9*(sj0*sj0)))+(((0.96)*gconst14*gconst3))+(((-1.0)*gconst0*gconst12*gconst15*gconst3))+(((2.64)*gconst13*gconst6*sj0))+((gconst0*gconst11*gconst14*gconst5))+(((4.1195)*gconst11*sj0))+((gconst12*gconst2*gconst7*gconst9))+(((-1.4795)*gconst14*sj0))+(((-1.0)*gconst12*gconst3*gconst7*gconst8))+(((-0.055)*gconst6*gconst9*sj0))+(((-3.3375)*gconst1*gconst12*(sj0*sj0)))+(((3.39025)*gconst12*(sj0*sj0)))+(((1.3775)*gconst0*gconst13*(sj0*sj0)))+(((-1.0)*gconst10*gconst5*gconst6*gconst9))+(((2.64)*gconst2*gconst9*sj0))+(((-1.0)*gconst14*gconst2*gconst5*gconst9))+(((0.275)*gconst14*gconst9*sj0))+(((0.275)*gconst1*gconst6*sj0))+(((-0.0625)*gconst1*gconst4*(sj0*sj0)))+(((-1.0)*gconst13*gconst2*gconst6*gconst9))+(((-1.21)*gconst15*gconst2))+(((-1.21)*gconst15*gconst3))+(((0.275)*gconst11*gconst12*sj0))+(((1.595)*gconst13*gconst3*sj0))+(((2.64)*gconst14*gconst5*sj0))+(((-0.055)*gconst1*gconst14*sj0))+(((2.64)*gconst1*gconst10*sj0))+(((1.595)*gconst13*gconst2*sj0))+(((-0.9025)*gconst4*gconst8*(sj0*sj0)))+((gconst15*gconst2*gconst4*gconst9))+((gconst10*gconst4*gconst7*gconst9))+((gconst0*gconst13*gconst14*gconst3))+(((-0.9025)*gconst0*gconst12*(sj0*sj0)))+(((-2.64)*gconst0*gconst11*sj0))+(((-2.11775)*gconst1*(sj0*sj0)))+((gconst0*gconst11*gconst13*gconst6))+(((-1.21)*gconst14*gconst2))+(((-1.21)*gconst3*gconst6))+(((1.595)*gconst10*gconst5*sj0))+(((2.632225)*(sj0*sj0)))+(((-1.045)*gconst12*gconst2*sj0))+((gconst1*gconst10*gconst15*gconst4))+(((-1.045)*gconst7*gconst8*sj0))+(((-1.0)*gconst1*gconst13*gconst14*gconst2))+(((-1.045)*gconst0*gconst15*sj0))+(((-4.1195)*gconst3*sj0))+(((-3.39025)*gconst4*(sj0*sj0)))+(((-2.64)*gconst15*gconst4*sj0))+((gconst14*gconst3*gconst5*gconst8))+(((1.595)*gconst1*gconst15*sj0))+(((-1.045)*gconst10*gconst4*sj0))+(((-1.045)*gconst6*gconst8*sj0))+(((-2.64)*gconst3*gconst8*sj0))+(((-1.0)*gconst0*gconst11*gconst15*gconst4))+(((-2.695)*gconst11*gconst4*sj0))+((gconst13*gconst3*gconst6*gconst8))+((gconst1*gconst12*gconst15*gconst2))+(((-1.045)*gconst0*gconst14*sj0))+(((-1.21)*gconst11*gconst14))+(((-1.21)*gconst10*gconst7))+(((-1.21)*gconst10*gconst6))+(((-2.695)*gconst12*gconst3*sj0))+(((2.11775)*gconst9*(sj0*sj0)))+(((-3.3375)*gconst4*gconst9*(sj0*sj0)))+(((-1.0)*gconst1*gconst10*gconst14*gconst5))+(((-2.1025)*gconst1*gconst13*(sj0*sj0)))+(((-1.21)*gconst11*gconst7))+(((-1.0)*gconst11*gconst4*gconst7*gconst8))+(((-1.0)*gconst15*gconst3*gconst4*gconst8)));
op[5]=((((-1.1)*gconst11*gconst5*gconst6))+(((1.45)*gconst1*gconst14*gconst5*sj0))+(((-1.45)*gconst3*gconst5*gconst8*sj0))+(((-1.1)*gconst13*gconst3*gconst6))+(((-1.1)*gconst2*gconst7*gconst9))+(((-2.295)*gconst12*gconst3*sj0))+(((1.45)*gconst5*gconst6*gconst9*sj0))+(((-0.95)*gconst5*gconst6*gconst8*sj0))+(((-1.111)*gconst4*(sj0*sj0)))+(((-0.33)*gconst9*(sj0*sj0)))+(((2.904)*gconst7*sj0))+(((1.1)*gconst15*gconst2*gconst4))+(((-1.1)*gconst1*gconst4*(sj0*sj0)))+(((-1.1)*gconst14*gconst2*gconst5))+(((3.751)*gconst1*(sj0*sj0)))+(((1.45)*gconst1*gconst13*gconst2*sj0))+(((-0.33)*gconst12*(sj0*sj0)))+(((0.95)*gconst0*gconst15*gconst4*sj0))+(((2.904)*gconst2*sj0))+(((-1.1)*gconst13*gconst2*gconst6))+(((1.1)*gconst0*gconst14*gconst3))+(((-1.1)*gconst1*gconst10*gconst6))+(((-1.1)*gconst1*gconst10*gconst7))+(((-1.45)*gconst4*gconst7*gconst9*sj0))+(((-2.295)*gconst11*gconst4*sj0))+(((1.5725)*gconst3*sj0))+(((1.1)*gconst3*gconst6))+(((1.45)*gconst1*gconst13*gconst6*sj0))+(((0.95)*gconst0*gconst12*gconst3*sj0))+(((1.45)*gconst1*gconst10*gconst5*sj0))+(((-1.1)*gconst14*gconst3*gconst5))+(((-2.295)*gconst1*gconst14*sj0))+(((-1.1)*gconst2*gconst6*gconst9))+(((1.1)*gconst0*gconst11*gconst6))+(((1.1)*gconst0*gconst11*gconst7))+(((-0.95)*gconst1*gconst12*gconst2*sj0))+(((-1.584)*(sj0*sj0)))+(((-1.1)*gconst11*gconst6))+(((1.1)*gconst11*gconst4*gconst7))+(((-3.828)*gconst5*(sj0*sj0)))+(((-2.295)*gconst6*gconst9*sj0))+(((-0.95)*gconst0*gconst14*gconst5*sj0))+(((1.1)*gconst0*gconst15*gconst3))+(((1.45)*gconst2*gconst5*gconst9*sj0))+(((-0.9725)*gconst6*sj0))+(((-1.45)*gconst1*gconst12*gconst7*sj0))+(((0.95)*gconst0*gconst12*gconst7*sj0))+(((-1.1)*gconst1*gconst14*gconst2))+(((1.1)*gconst10*gconst4*gconst7))+(((2.295)*gconst3*gconst4*sj0))+(((1.1)*gconst1*gconst12*(sj0*sj0)))+(((1.452)*gconst11*sj0))+(((-0.95)*gconst2*gconst4*gconst9*sj0))+(((2.508)*gconst0*(sj0*sj0)))+(((-1.45)*gconst1*gconst15*gconst4*sj0))+(((1.1)*gconst4*gconst9*(sj0*sj0)))+(((-1.1)*gconst1*gconst15*gconst2))+(((-1.1)*gconst10*gconst5*gconst6))+(((1.1)*gconst3*gconst6*gconst8))+(((0.95)*gconst4*gconst7*gconst8*sj0))+(((-1.45)*gconst0*gconst11*gconst5*sj0))+(((1.1)*gconst3*gconst7*gconst8))+(((1.1)*gconst12*gconst2*gconst7))+(((0.95)*gconst0*gconst11*gconst4*sj0))+(((2.295)*gconst1*gconst6*sj0))+(((1.452)*gconst14*sj0))+(((-0.95)*gconst0*gconst13*gconst6*sj0))+(((1.1)*gconst15*gconst3*gconst4))+(((-1.45)*gconst0*gconst13*gconst3*sj0))+(((-1.1)*gconst14*gconst3))+(((-0.95)*gconst1*gconst10*gconst4*sj0))+(((1.1)*gconst12*gconst3*gconst7))+(((0.95)*gconst3*gconst4*gconst8*sj0)));
op[6]=((((-1.0)*x271*x297))+(((-1.0)*x271*x290))+(((-0.055)*x305))+((x289*x297))+(((2.11775)*x304))+(((-1.0)*gconst8*x261*x274))+(((-1.0)*gconst2*x267*x291))+(((-1.0)*gconst14*x264*x267))+(((4.1195)*x287))+(((-2.1025)*gconst5*x304))+((x269*x282))+(((-2.695)*sj0*x261))+((x249*x250))+(((-1.0)*gconst0*gconst15*x261))+((gconst14*gconst3*x252))+(((-3.3375)*gconst4*x304))+((gconst10*gconst4*x283))+((x282*x299))+((x264*x265))+(((-1.0)*gconst0*gconst4*x309))+((gconst0*gconst13*x284))+(((-1.0)*x253*x298))+(((-1.0)*x253*x293))+(((-1.0)*x250*x289))+(((0.96)*x284))+((x271*x282))+(((-1.0)*x253*x260))+(((-1.0)*gconst3*x251*x260))+x317+(((-1.0)*gconst10*x250*x267))+(((-1.0)*gconst6*x262))+(((-1.0)*x318))+(((-1.0)*gconst3*x257))+((gconst3*gconst5*x265))+((gconst4*x308))+(((-1.0)*gconst4*x249*x274))+((x252*x303))+((x250*x279))+((x250*x271))+(((-1.0)*gconst2*x257))+((x265*x283))+(((-1.21)*gconst2*gconst6)));
op[7]=((((-2.295)*sj0*x261))+(((-1.0)*gconst4*x277*x282))+(((-1.45)*x252*x287))+((gconst6*x296))+(((-0.33)*x304))+((x261*x281))+((x264*x306))+(((-1.1)*gconst2*x250))+((x260*x278))+((gconst4*x260*x277))+((x281*x293))+(((-2.295)*x305))+(((-1.0)*gconst6*x278))+(((-1.45)*gconst4*sj0*x283))+(((-1.1)*gconst6*x282))+(((-1.0)*x281*x282))+(((-1.0)*x250*x278))+(((1.1)*gconst4*x304))+((x278*x298))+((gconst0*x261*x277))+(((-1.0)*gconst4*x310))+(((1.452)*x287))+((x250*x306))+(((-1.0)*gconst0*x250*x277)));
op[8]=(((gconst1*gconst6*x270))+((x250*x290))+((x282*x297))+(((-1.21)*x284))+(((-1.0)*x260*x261))+((x261*x270))+(((-1.0)*x255*x304))+(((-1.0)*gconst2*x250*x267)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
tj1 = IKtan(j1);
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x319=(cj1*r21);
IkReal x320=(sj4*sj5);
IkReal x321=(cj1*r22);
IkReal x322=((2.59805588659292)*cj5);
IkReal x323=(r21*sj1);
IkReal x324=((8.0)*pz);
IkReal x325=(cj4*sj1);
IkReal x326=(cj1*cj4);
IkReal x327=((0.433012701892219)*cj5);
IkReal x328=(r20*sj1);
IkReal x329=(cj5*sj4);
IkReal x330=(r22*sj1);
IkReal x331=((2.59805588659292)*sj5);
IkReal x332=(r22*x325);
IkReal x333=((1.90525588832577)*cj4*cj5);
IkReal x334=((0.433012701892219)*r20*sj5);
IkReal x335=((1.90525588832577)*r20*sj5);
IkReal x336=(cj1*r20*x329);
if( IKabs((((cj4*x319*x327))+((x322*x323))+(((-0.75)*cj4*x321))+(((-0.866025403784439)*x319*x320))+(((-0.25)*x321))+(((1.1)*x330))+(((3.3)*x332))+(((0.866025403784439)*x336))+(((-4.8)*cj1*sj1))+(((-1.0)*x319*x327))+((sj1*x324))+((x328*x331))+(((-1.0)*x323*x333))+((x326*x334))+(((-1.0)*cj1*x334))+(((-1.0)*x325*x335))+(((3.81051177665153)*x320*x323))+(((-3.81051177665153)*x328*x329)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((1.1)*x321))+(((0.866025403784439)*x320*x323))+(((-4.8)*(cj1*cj1)))+((cj1*x324))+((x323*x327))+(((0.433012701892219)*sj5*x328))+(((0.25)*x330))+(((-1.0)*x319*x333))+(((-3.81051177665153)*x336))+(((-1.0)*cj4*x323*x327))+((cj1*r20*x331))+(((-0.866025403784439)*x328*x329))+(((0.75)*x332))+(((3.3)*cj4*x321))+(((3.81051177665153)*x319*x320))+(((-1.0)*x325*x334))+(((-1.0)*x326*x335))+((x319*x322)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*x319*x327))+((x322*x323))+(((-0.75)*cj4*x321))+(((-0.866025403784439)*x319*x320))+(((-0.25)*x321))+(((1.1)*x330))+(((3.3)*x332))+(((0.866025403784439)*x336))+(((-4.8)*cj1*sj1))+(((-1.0)*x319*x327))+((sj1*x324))+((x328*x331))+(((-1.0)*x323*x333))+((x326*x334))+(((-1.0)*cj1*x334))+(((-1.0)*x325*x335))+(((3.81051177665153)*x320*x323))+(((-3.81051177665153)*x328*x329))))+IKsqr(((((1.1)*x321))+(((0.866025403784439)*x320*x323))+(((-4.8)*(cj1*cj1)))+((cj1*x324))+((x323*x327))+(((0.433012701892219)*sj5*x328))+(((0.25)*x330))+(((-1.0)*x319*x333))+(((-3.81051177665153)*x336))+(((-1.0)*cj4*x323*x327))+((cj1*r20*x331))+(((-0.866025403784439)*x328*x329))+(((0.75)*x332))+(((3.3)*cj4*x321))+(((3.81051177665153)*x319*x320))+(((-1.0)*x325*x334))+(((-1.0)*x326*x335))+((x319*x322))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj4*x319*x327))+((x322*x323))+(((-0.75)*cj4*x321))+(((-0.866025403784439)*x319*x320))+(((-0.25)*x321))+(((1.1)*x330))+(((3.3)*x332))+(((0.866025403784439)*x336))+(((-4.8)*cj1*sj1))+(((-1.0)*x319*x327))+((sj1*x324))+((x328*x331))+(((-1.0)*x323*x333))+((x326*x334))+(((-1.0)*cj1*x334))+(((-1.0)*x325*x335))+(((3.81051177665153)*x320*x323))+(((-3.81051177665153)*x328*x329))), ((((1.1)*x321))+(((0.866025403784439)*x320*x323))+(((-4.8)*(cj1*cj1)))+((cj1*x324))+((x323*x327))+(((0.433012701892219)*sj5*x328))+(((0.25)*x330))+(((-1.0)*x319*x333))+(((-3.81051177665153)*x336))+(((-1.0)*cj4*x323*x327))+((cj1*r20*x331))+(((-0.866025403784439)*x328*x329))+(((0.75)*x332))+(((3.3)*cj4*x321))+(((3.81051177665153)*x319*x320))+(((-1.0)*x325*x334))+(((-1.0)*x326*x335))+((x319*x322))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
tj2 = IKtan(j2);
{
IkReal evalcond[9];
IkReal x337=IKsin(j2);
IkReal x338=IKcos(j2);
IkReal x339=((0.0865999997833942)*sj5);
IkReal x340=(cj3*r20);
IkReal x341=(r21*sj3);
IkReal x342=(cj5*r01);
IkReal x343=((0.866025403784439)*sj4);
IkReal x344=(cj5*r20);
IkReal x345=(r10*sj3);
IkReal x346=(cj4*cj5);
IkReal x347=(cj4*sj5);
IkReal x348=(r11*sj3);
IkReal x349=(cj0*sj1);
IkReal x350=((0.75)*sj5);
IkReal x351=((0.433012701892219)*cj3);
IkReal x352=((0.433012701892219)*sj5);
IkReal x353=((0.25)*cj3);
IkReal x354=(cj5*r21);
IkReal x355=((1.0)*cj0);
IkReal x356=((0.125)*cj0);
IkReal x357=((0.75)*cj4);
IkReal x358=(sj0*sj1);
IkReal x359=(r01*sj3);
IkReal x360=(r00*sj3);
IkReal x361=(cj5*r11);
IkReal x362=((0.75)*cj3);
IkReal x363=(cj3*r10);
IkReal x364=(cj3*r00);
IkReal x365=((0.125)*sj0);
IkReal x366=((0.5)*cj5*sj4);
IkReal x367=(sj1*x338);
IkReal x368=(cj1*x337);
IkReal x369=((0.5)*sj4*sj5);
IkReal x370=((0.55)*x337);
IkReal x371=(cj1*x338);
IkReal x372=(sj1*x337);
evalcond[0]=((((-1.0)*r20*x339))+(((0.55)*x368))+(((-1.0)*pz))+(((-0.55)*x367))+(((0.125)*x372))+(((0.125)*x371))+(((0.6)*cj1))+(((-0.0865999997833942)*x354)));
evalcond[1]=((((-0.0865999997833942)*x342))+(((-0.6)*x358))+(((-1.0)*r00*x339))+(((-1.0)*x358*x370))+((x365*x368))+(((-0.135)*sj0))+(((-1.0)*px))+(((-0.55)*sj0*x371))+(((-0.125)*x338*x358)));
evalcond[2]=((((-1.0)*x356*x368))+(((-0.0865999997833942)*x361))+(((0.125)*x338*x349))+(((-1.0)*py))+(((0.6)*x349))+(((0.135)*cj0))+((x349*x370))+(((-1.0)*r10*x339))+(((0.55)*cj0*x371)));
evalcond[3]=((((-0.433012701892219)*x354))+(((-1.0)*x368))+(((-1.0)*r22*x357))+(((0.433012701892219)*r21*x346))+(((0.433012701892219)*r20*x347))+x367+(((-0.25)*r22))+(((-1.0)*r20*x352))+((x343*x344))+(((-1.0)*r21*sj5*x343)));
evalcond[4]=(((x337*x358))+(((-0.25)*r02))+((sj0*x371))+(((-0.433012701892219)*x342))+(((0.433012701892219)*cj4*x342))+(((0.433012701892219)*r00*x347))+(((-1.0)*r01*sj5*x343))+((cj5*r00*x343))+(((-1.0)*r00*x352))+(((-1.0)*r02*x357)));
evalcond[5]=((((-1.0)*r12*x357))+(((-0.25)*r12))+(((-1.0)*x355*x371))+(((-1.0)*r11*sj5*x343))+(((0.433012701892219)*r10*x347))+((cj5*r10*x343))+(((-1.0)*x337*x349))+(((-0.433012701892219)*x361))+(((0.433012701892219)*r11*x346))+(((-1.0)*r10*x352)));
evalcond[6]=((((-1.0)*r22*sj3*x343))+(((-0.25)*x340*x347))+((cj3*r21*x369))+(((-1.0)*r22*x351))+((r20*sj3*x369))+(((-1.0)*x354*x362))+((x341*x366))+(((-1.0)*r21*x346*x353))+(((-1.0)*cj4*sj3*x344))+x372+x371+(((-1.0)*x340*x366))+((x341*x347))+(((-1.0)*x340*x350))+((cj4*r22*x351)));
evalcond[7]=((((-1.0)*x346*x360))+((cj4*r02*x351))+(((-1.0)*r00*x347*x353))+(((-1.0)*x350*x364))+(((-1.0)*x338*x358))+((sj0*x368))+(((0.5)*sj3*sj4*x342))+((cj3*r01*x369))+(((-1.0)*x342*x362))+(((-1.0)*cj4*x342*x353))+((x347*x359))+(((-1.0)*r02*sj3*x343))+(((-1.0)*x364*x366))+(((-1.0)*r02*x351))+((x360*x369)));
evalcond[8]=((((-1.0)*r11*x346*x353))+(((-1.0)*x363*x366))+(((-1.0)*x361*x362))+(((-1.0)*x350*x363))+(((-1.0)*r12*x351))+(((-1.0)*x355*x368))+((cj4*r12*x351))+((cj3*r11*x369))+((x347*x348))+((x345*x369))+(((-1.0)*r10*x347*x353))+(((-1.0)*x345*x346))+((x338*x349))+((x348*x366))+(((-1.0)*r12*sj3*x343)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x373=(r21*sj0);
IkReal x374=((0.5)*sj4);
IkReal x375=(cj4*sj5);
IkReal x376=(r20*sj0);
IkReal x377=((0.866025403784439)*sj4);
IkReal x378=(cj4*cj5);
IkReal x379=((0.433012701892219)*r22*sj0);
CheckValue<IkReal> x380=IKPowWithIntegerCheck(IKsign((((r01*(((((-1.0)*sj5*x377))+(((-0.433012701892219)*cj5))+(((0.433012701892219)*x378))))))+((r00*((((cj5*x377))+(((-0.433012701892219)*sj5))+(((0.433012701892219)*x375))))))+((r02*(((-0.25)+(((-0.75)*cj4)))))))),-1);
if(!x380.valid){
continue;
}
CheckValue<IkReal> x381 = IKatan2WithCheck(IkReal((((sj5*x374*x376))+(((-1.0)*r22*sj0*x377))+((cj5*x373*x374))+((x373*x375))+(((-1.0)*x376*x378)))),IkReal(((((-0.75)*sj5*x376))+(((-0.25)*x375*x376))+(((-1.0)*x379))+(((-1.0)*cj5*x374*x376))+((cj4*x379))+((sj5*x373*x374))+(((-0.25)*x373*x378))+(((-0.75)*cj5*x373)))),IKFAST_ATAN2_MAGTHRESH);
if(!x381.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x380.value)))+(x381.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
tj3 = IKtan(j3);
{
IkReal evalcond[3];
IkReal x382=IKsin(j3);
IkReal x383=IKcos(j3);
IkReal x384=((0.5)*sj4);
IkReal x385=((1.0)*cj4);
IkReal x386=((0.25)*cj4);
IkReal x387=((0.433012701892219)*x382);
IkReal x388=(cj5*x382);
IkReal x389=(sj5*x382);
IkReal x390=(sj5*x383);
IkReal x391=(cj5*x383);
IkReal x392=((0.866025403784439)*sj4*x383);
evalcond[0]=((((-1.0)*r20*x385*x391))+((r22*x387))+((r20*x384*x390))+((r21*x386*x388))+(((0.75)*r21*x388))+(((0.75)*r20*x389))+((r20*x386*x389))+((r20*x384*x388))+(((-1.0)*r21*x384*x389))+(((-1.0)*cj4*r22*x387))+((cj4*r21*x390))+((r21*x384*x391))+(((-1.0)*r22*x392)));
evalcond[1]=((((0.75)*r01*x388))+cj0+(((-1.0)*r00*x385*x391))+((r00*x384*x390))+(((-1.0)*cj4*r02*x387))+((r01*x386*x388))+(((-1.0)*r02*x392))+((r02*x387))+(((-1.0)*r01*x384*x389))+(((0.75)*r00*x389))+((r00*x384*x388))+((cj4*r01*x390))+((r01*x384*x391))+((r00*x386*x389)));
evalcond[2]=(sj0+((r10*x384*x388))+((cj4*r11*x390))+((r12*x387))+(((-1.0)*r12*x392))+((r10*x386*x389))+((r11*x384*x391))+(((0.75)*r10*x389))+(((-1.0)*r10*x385*x391))+((r10*x384*x390))+(((-1.0)*r11*x384*x389))+((r11*x386*x388))+(((-1.0)*cj4*r12*x387))+(((0.75)*r11*x388)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[8+1], zeror[8];
int numroots;
IkReal x393=((1.0)*px);
IkReal x394=((0.0865999997833942)*sj5);
IkReal x395=((0.0865999997833942)*cj5);
IkReal x396=(r01*x395);
IkReal x397=(r00*x394);
IkReal x398=(((r20*x394))+(((1.0)*pz))+((r21*x395)));
IkReal x399=((0.725)+(((-1.0)*x398)));
IkReal x400=((0.475)+(((-1.0)*x398)));
IkReal x401=((-0.725)+(((-1.0)*x398)));
IkReal x402=((-0.475)+(((-1.0)*x398)));
IkReal x403=(x397+x396+x393);
IkReal x404=((((0.415)*sj0))+(((-1.0)*x403)));
IkReal x405=((((-0.685)*sj0))+(((-1.0)*x403)));
IkReal gconst0=x399;
IkReal gconst1=x400;
IkReal gconst2=x405;
IkReal gconst3=x404;
IkReal gconst4=x399;
IkReal gconst5=x400;
IkReal gconst6=x405;
IkReal gconst7=x404;
IkReal gconst8=x401;
IkReal gconst9=x402;
IkReal gconst10=x404;
IkReal gconst11=x405;
IkReal gconst12=x401;
IkReal gconst13=x402;
IkReal gconst14=x404;
IkReal gconst15=x405;
IkReal x406=sj0*sj0;
IkReal x407=(gconst0*gconst11);
IkReal x408=(gconst5*gconst6);
IkReal x409=((1.0)*gconst12);
IkReal x410=(gconst0*gconst5);
IkReal x411=((1.045)*sj0);
IkReal x412=(gconst14*gconst8);
IkReal x413=((0.0625)*gconst4);
IkReal x414=(gconst13*gconst14);
IkReal x415=((1.21)*gconst7);
IkReal x416=(gconst13*sj0);
IkReal x417=(gconst10*gconst9);
IkReal x418=(gconst0*gconst7);
IkReal x419=(gconst3*gconst4);
IkReal x420=((1.4795)*sj0);
IkReal x421=(gconst11*gconst8);
IkReal x422=(gconst2*gconst5);
IkReal x423=((1.595)*sj0);
IkReal x424=(gconst11*sj0);
IkReal x425=((1.0)*gconst1);
IkReal x426=((1.21)*gconst11);
IkReal x427=(gconst15*gconst4);
IkReal x428=((0.275)*sj0);
IkReal x429=((2.64)*sj0);
IkReal x430=(gconst11*gconst14);
IkReal x431=(gconst9*sj0);
IkReal x432=((1.0)*gconst7);
IkReal x433=(gconst10*gconst15);
IkReal x434=((1.1)*gconst12);
IkReal x435=((0.95)*sj0);
IkReal x436=((1.1)*gconst3);
IkReal x437=(gconst3*gconst8);
IkReal x438=(gconst15*gconst9);
IkReal x439=((1.1)*gconst7);
IkReal x440=(gconst1*gconst2);
IkReal x441=(gconst1*gconst7);
IkReal x442=(gconst3*gconst6);
IkReal x443=((1.1)*gconst11);
IkReal x444=((0.0625)*gconst12);
IkReal x445=(gconst3*sj0);
IkReal x446=(gconst12*gconst8);
IkReal x447=(gconst2*gconst9);
IkReal x448=(gconst0*gconst3);
IkReal x449=(gconst13*gconst6);
IkReal x450=((1.21)*gconst14);
IkReal x451=(gconst2*gconst4);
IkReal x452=((1.1)*gconst15);
IkReal x453=(gconst12*gconst15);
IkReal x454=((1.452)*sj0);
IkReal x455=(gconst4*gconst7);
IkReal x456=(gconst0*gconst6);
IkReal x457=(gconst12*gconst7);
IkReal x458=(gconst6*x426);
IkReal x459=(gconst3*x450);
IkReal x460=((1.7424)*x406);
IkReal x461=((1.3775)*x406);
IkReal x462=(gconst1*x406);
IkReal x463=(gconst1*gconst6*sj0);
IkReal x464=((1.45)*gconst1*sj0);
IkReal x465=(gconst9*x406);
IkReal x466=((3.39025)*x406);
IkReal x467=((0.9025)*x406);
IkReal x468=((0.33)*x406);
IkReal x469=(gconst12*gconst3*x428);
IkReal x470=(gconst1*gconst14*x428);
IkReal x471=((0.275)*gconst4*x424);
IkReal x472=(gconst6*gconst9*x428);
IkReal x473=(x413*x465);
IkReal x474=(x444*x462);
IkReal x475=(x469+x470+x471+x472);
IkReal x476=(x458+x459+x460+x474+x473);
op[0]=((((-1.0)*gconst14*x426))+(((-1.0)*x414*x417))+(((-1.0)*gconst15*x409*x421))+(((0.275)*gconst12*x424))+((gconst14*gconst9*x428))+((x417*x453))+((gconst11*gconst13*x412))+(((-1.0)*x444*x465)));
op[1]=((((1.1)*x430))+(((1.452)*x424))+(((-1.0)*gconst12*x417*x435))+(((-1.1)*gconst14*x417))+(((-0.33)*x465))+(((-1.0)*gconst12*x468))+(((1.45)*x414*x431))+((gconst11*gconst15*x434))+(((2.295)*gconst14*x431))+(((-0.95)*x412*x416))+(((-1.0)*x417*x452))+((gconst15*x435*x446))+(((-1.1)*gconst10*x414))+((x412*x443))+((gconst12*x421*x435))+(((2.295)*gconst12*x424))+(((1.45)*x416*x417))+((x421*x452))+(((-1.0)*x414*x443))+((gconst14*x454))+((x433*x434))+(((-1.0)*x434*x465))+(((-1.45)*x416*x421))+(((-1.45)*x431*x453)));
op[2]=(((x421*x449))+(((-2.695)*gconst12*x424))+(((-1.0)*x421*x429))+((x407*x414))+(((-1.0)*x446*x467))+(((-3.3375)*gconst12*x465))+(((0.96)*x430))+((gconst11*gconst5*x412))+(((-1.0)*gconst10*x450))+(((-0.055)*gconst14*x431))+(((-1.0)*gconst12*x466))+((x414*x429))+(((-1.0)*x414*x447))+(((-4.1195)*x424))+(((-1.0)*x421*x427))+(((-2.1025)*gconst13*x465))+((x417*x457))+(((-1.0)*gconst15*x409*x437))+(((-1.0)*gconst15*x426))+(((-1.0)*x476))+(((-1.0)*gconst10*x414*x425))+((gconst12*gconst2*x438))+(((-1.0)*gconst15*x407*x409))+((gconst14*x420))+(((-1.21)*x433))+x475+((x423*x438))+((gconst13*gconst3*x412))+(((-1.0)*gconst15*gconst8*x411))+(((1.595)*gconst11*x416))+(((-1.0)*gconst14*gconst5*x417))+(((-1.0)*x411*x412))+(((-2.11775)*x465))+((gconst13*gconst8*x461))+(((-1.0)*x417*x449))+(((1.595)*gconst10*x416))+(((-1.0)*x429*x453))+((gconst1*gconst12*x433))+(((-1.0)*gconst10*gconst12*x411))+(((-1.0)*gconst7*x409*x421))+((x417*x429))+((x417*x427)));
op[3]=((((-0.95)*gconst0*gconst13*gconst14*sj0))+(((1.584)*(sj0*sj0)))+(((2.295)*gconst6*gconst9*sj0))+(((-1.45)*gconst0*gconst11*gconst13*sj0))+(((1.1)*gconst12*gconst15*gconst3))+(((1.1)*gconst12*gconst15*gconst2))+(((-1.45)*gconst11*gconst5*gconst8*sj0))+(((-0.95)*gconst1*gconst10*gconst12*sj0))+(((-1.1)*gconst13*gconst14*gconst2))+(((-1.1)*gconst13*gconst14*gconst3))+(((2.295)*gconst11*gconst4*sj0))+(((2.904)*gconst10*sj0))+(((1.1)*gconst11*gconst6*gconst8))+(((-1.1)*gconst11*gconst13*gconst6))+(((2.508)*gconst8*(sj0*sj0)))+(((-1.1)*gconst10*gconst6*gconst9))+(((-0.33)*gconst4*(sj0*sj0)))+(((0.95)*gconst11*gconst4*gconst8*sj0))+(((-1.45)*gconst1*gconst12*gconst15*sj0))+(((-1.1)*gconst14*gconst2*gconst9))+(((-2.295)*gconst14*gconst9*sj0))+(((1.1)*gconst11*gconst6))+(((-1.45)*gconst13*gconst3*gconst8*sj0))+(((0.95)*gconst15*gconst4*gconst8*sj0))+(((1.45)*gconst1*gconst13*gconst14*sj0))+(((-1.1)*gconst10*gconst14*gconst5))+(((0.95)*gconst12*gconst7*gconst8*sj0))+(((-1.45)*gconst12*gconst7*gconst9*sj0))+(((2.295)*gconst1*gconst14*sj0))+(((1.45)*gconst13*gconst6*gconst9*sj0))+(((-0.95)*gconst13*gconst6*gconst8*sj0))+(((1.45)*gconst10*gconst5*gconst9*sj0))+(((-0.9725)*gconst14*sj0))+(((1.1)*gconst0*gconst11*gconst14))+(((1.1)*gconst0*gconst11*gconst15))+(((-1.1)*gconst11*gconst14))+(((1.1)*gconst11*gconst12*gconst7))+(((1.1)*gconst11*gconst15*gconst4))+(((1.45)*gconst14*gconst5*gconst9*sj0))+(((3.751)*gconst9*(sj0*sj0)))+(((-1.1)*gconst4*gconst9*(sj0*sj0)))+(((-1.1)*gconst1*gconst12*(sj0*sj0)))+(((-1.45)*gconst15*gconst4*gconst9*sj0))+(((1.452)*gconst6*sj0))+(((-1.1)*gconst10*gconst13*gconst6))+(((-1.1)*gconst11*gconst14*gconst5))+(((0.95)*gconst12*gconst3*gconst8*sj0))+(((2.904)*gconst15*sj0))+(((-0.95)*gconst14*gconst5*gconst8*sj0))+(((1.45)*gconst13*gconst2*gconst9*sj0))+(((-0.95)*gconst10*gconst4*gconst9*sj0))+(((2.295)*gconst12*gconst3*sj0))+(((-1.1)*gconst10*gconst7*gconst9))+(((1.452)*gconst3*sj0))+(((1.1)*gconst10*gconst12*gconst7))+(((-0.33)*gconst1*(sj0*sj0)))+(((1.1)*gconst12*gconst9*(sj0*sj0)))+(((0.95)*gconst0*gconst11*gconst12*sj0))+(((1.5725)*gconst11*sj0))+(((1.1)*gconst10*gconst15*gconst4))+(((1.1)*gconst15*gconst3*gconst8))+(((0.95)*gconst0*gconst12*gconst15*sj0))+(((-1.111)*gconst12*(sj0*sj0)))+(((1.1)*gconst14*gconst3*gconst8))+(((-1.1)*gconst15*gconst2*gconst9))+(((1.1)*gconst14*gconst3))+(((-3.828)*gconst13*(sj0*sj0)))+(((-0.95)*gconst12*gconst2*gconst9*sj0))+(((1.45)*gconst1*gconst10*gconst13*sj0))+(((-2.295)*gconst11*gconst12*sj0))+(((1.1)*gconst11*gconst7*gconst8))+(((-1.1)*gconst1*gconst10*gconst14))+(((-1.1)*gconst1*gconst10*gconst15)));
op[4]=((((-1.0)*gconst0*gconst11*gconst12*gconst7))+(((-2.64)*gconst12*gconst7*sj0))+(((1.3775)*gconst5*gconst8*(sj0*sj0)))+((gconst1*gconst10*gconst12*gconst7))+(((0.275)*gconst3*gconst4*sj0))+(((1.4795)*gconst6*sj0))+(((1.595)*gconst7*gconst9*sj0))+(((0.96)*gconst11*gconst6))+(((-1.0)*gconst1*gconst10*gconst13*gconst6))+(((-2.1025)*gconst5*gconst9*(sj0*sj0)))+(((1.595)*gconst11*gconst5*sj0))+((gconst11*gconst5*gconst6*gconst8))+(((-0.0625)*gconst12*gconst9*(sj0*sj0)))+(((0.96)*gconst14*gconst3))+(((-1.0)*gconst0*gconst12*gconst15*gconst3))+(((2.64)*gconst13*gconst6*sj0))+((gconst0*gconst11*gconst14*gconst5))+(((4.1195)*gconst11*sj0))+((gconst12*gconst2*gconst7*gconst9))+(((-1.4795)*gconst14*sj0))+(((-1.0)*gconst12*gconst3*gconst7*gconst8))+(((-0.055)*gconst6*gconst9*sj0))+(((-3.3375)*gconst1*gconst12*(sj0*sj0)))+(((3.39025)*gconst12*(sj0*sj0)))+(((1.3775)*gconst0*gconst13*(sj0*sj0)))+(((-1.0)*gconst10*gconst5*gconst6*gconst9))+(((2.64)*gconst2*gconst9*sj0))+(((-1.0)*gconst14*gconst2*gconst5*gconst9))+(((0.275)*gconst14*gconst9*sj0))+(((0.275)*gconst1*gconst6*sj0))+(((-0.0625)*gconst1*gconst4*(sj0*sj0)))+(((-1.0)*gconst13*gconst2*gconst6*gconst9))+(((-1.21)*gconst15*gconst2))+(((-1.21)*gconst15*gconst3))+(((0.275)*gconst11*gconst12*sj0))+(((1.595)*gconst13*gconst3*sj0))+(((2.64)*gconst14*gconst5*sj0))+(((-0.055)*gconst1*gconst14*sj0))+(((2.64)*gconst1*gconst10*sj0))+(((1.595)*gconst13*gconst2*sj0))+(((-0.9025)*gconst4*gconst8*(sj0*sj0)))+((gconst15*gconst2*gconst4*gconst9))+((gconst10*gconst4*gconst7*gconst9))+((gconst0*gconst13*gconst14*gconst3))+(((-0.9025)*gconst0*gconst12*(sj0*sj0)))+(((-2.64)*gconst0*gconst11*sj0))+(((-2.11775)*gconst1*(sj0*sj0)))+((gconst0*gconst11*gconst13*gconst6))+(((-1.21)*gconst14*gconst2))+(((-1.21)*gconst3*gconst6))+(((1.595)*gconst10*gconst5*sj0))+(((2.632225)*(sj0*sj0)))+(((-1.045)*gconst12*gconst2*sj0))+((gconst1*gconst10*gconst15*gconst4))+(((-1.045)*gconst7*gconst8*sj0))+(((-1.0)*gconst1*gconst13*gconst14*gconst2))+(((-1.045)*gconst0*gconst15*sj0))+(((-4.1195)*gconst3*sj0))+(((-3.39025)*gconst4*(sj0*sj0)))+(((-2.64)*gconst15*gconst4*sj0))+((gconst14*gconst3*gconst5*gconst8))+(((1.595)*gconst1*gconst15*sj0))+(((-1.045)*gconst10*gconst4*sj0))+(((-1.045)*gconst6*gconst8*sj0))+(((-2.64)*gconst3*gconst8*sj0))+(((-1.0)*gconst0*gconst11*gconst15*gconst4))+(((-2.695)*gconst11*gconst4*sj0))+((gconst13*gconst3*gconst6*gconst8))+((gconst1*gconst12*gconst15*gconst2))+(((-1.045)*gconst0*gconst14*sj0))+(((-1.21)*gconst11*gconst14))+(((-1.21)*gconst10*gconst7))+(((-1.21)*gconst10*gconst6))+(((-2.695)*gconst12*gconst3*sj0))+(((2.11775)*gconst9*(sj0*sj0)))+(((-3.3375)*gconst4*gconst9*(sj0*sj0)))+(((-1.0)*gconst1*gconst10*gconst14*gconst5))+(((-2.1025)*gconst1*gconst13*(sj0*sj0)))+(((-1.21)*gconst11*gconst7))+(((-1.0)*gconst11*gconst4*gconst7*gconst8))+(((-1.0)*gconst15*gconst3*gconst4*gconst8)));
op[5]=((((-1.1)*gconst11*gconst5*gconst6))+(((1.45)*gconst1*gconst14*gconst5*sj0))+(((-1.45)*gconst3*gconst5*gconst8*sj0))+(((-1.1)*gconst13*gconst3*gconst6))+(((-1.1)*gconst2*gconst7*gconst9))+(((-2.295)*gconst12*gconst3*sj0))+(((1.45)*gconst5*gconst6*gconst9*sj0))+(((-0.95)*gconst5*gconst6*gconst8*sj0))+(((-1.111)*gconst4*(sj0*sj0)))+(((-0.33)*gconst9*(sj0*sj0)))+(((2.904)*gconst7*sj0))+(((1.1)*gconst15*gconst2*gconst4))+(((-1.1)*gconst1*gconst4*(sj0*sj0)))+(((-1.1)*gconst14*gconst2*gconst5))+(((3.751)*gconst1*(sj0*sj0)))+(((1.45)*gconst1*gconst13*gconst2*sj0))+(((-0.33)*gconst12*(sj0*sj0)))+(((0.95)*gconst0*gconst15*gconst4*sj0))+(((2.904)*gconst2*sj0))+(((-1.1)*gconst13*gconst2*gconst6))+(((1.1)*gconst0*gconst14*gconst3))+(((-1.1)*gconst1*gconst10*gconst6))+(((-1.1)*gconst1*gconst10*gconst7))+(((-1.45)*gconst4*gconst7*gconst9*sj0))+(((-2.295)*gconst11*gconst4*sj0))+(((1.5725)*gconst3*sj0))+(((1.1)*gconst3*gconst6))+(((1.45)*gconst1*gconst13*gconst6*sj0))+(((0.95)*gconst0*gconst12*gconst3*sj0))+(((1.45)*gconst1*gconst10*gconst5*sj0))+(((-1.1)*gconst14*gconst3*gconst5))+(((-2.295)*gconst1*gconst14*sj0))+(((-1.1)*gconst2*gconst6*gconst9))+(((1.1)*gconst0*gconst11*gconst6))+(((1.1)*gconst0*gconst11*gconst7))+(((-0.95)*gconst1*gconst12*gconst2*sj0))+(((-1.584)*(sj0*sj0)))+(((-1.1)*gconst11*gconst6))+(((1.1)*gconst11*gconst4*gconst7))+(((-3.828)*gconst5*(sj0*sj0)))+(((-2.295)*gconst6*gconst9*sj0))+(((-0.95)*gconst0*gconst14*gconst5*sj0))+(((1.1)*gconst0*gconst15*gconst3))+(((1.45)*gconst2*gconst5*gconst9*sj0))+(((-0.9725)*gconst6*sj0))+(((-1.45)*gconst1*gconst12*gconst7*sj0))+(((0.95)*gconst0*gconst12*gconst7*sj0))+(((-1.1)*gconst1*gconst14*gconst2))+(((1.1)*gconst10*gconst4*gconst7))+(((2.295)*gconst3*gconst4*sj0))+(((1.1)*gconst1*gconst12*(sj0*sj0)))+(((1.452)*gconst11*sj0))+(((-0.95)*gconst2*gconst4*gconst9*sj0))+(((2.508)*gconst0*(sj0*sj0)))+(((-1.45)*gconst1*gconst15*gconst4*sj0))+(((1.1)*gconst4*gconst9*(sj0*sj0)))+(((-1.1)*gconst1*gconst15*gconst2))+(((-1.1)*gconst10*gconst5*gconst6))+(((1.1)*gconst3*gconst6*gconst8))+(((0.95)*gconst4*gconst7*gconst8*sj0))+(((-1.45)*gconst0*gconst11*gconst5*sj0))+(((1.1)*gconst3*gconst7*gconst8))+(((1.1)*gconst12*gconst2*gconst7))+(((0.95)*gconst0*gconst11*gconst4*sj0))+(((2.295)*gconst1*gconst6*sj0))+(((1.452)*gconst14*sj0))+(((-0.95)*gconst0*gconst13*gconst6*sj0))+(((1.1)*gconst15*gconst3*gconst4))+(((-1.45)*gconst0*gconst13*gconst3*sj0))+(((-1.1)*gconst14*gconst3))+(((-0.95)*gconst1*gconst10*gconst4*sj0))+(((1.1)*gconst12*gconst3*gconst7))+(((0.95)*gconst3*gconst4*gconst8*sj0)));
op[6]=(((x407*x408))+(((-1.0)*gconst2*x425*x449))+(((0.96)*x442))+((x440*x457))+(((-1.0)*gconst10*x408*x425))+((gconst14*gconst3*x410))+(((-1.0)*x411*x451))+(((-1.0)*x411*x456))+(((4.1195)*x445))+((gconst10*gconst4*x441))+(((-1.0)*x476))+(((-1.0)*x429*x448))+(((-1.0)*gconst4*x407*x432))+((x447*x455))+((x408*x429))+((gconst4*x466))+x475+(((-2.1025)*gconst5*x462))+((x410*x461))+((gconst3*gconst5*x423))+(((-1.0)*gconst8*x419*x432))+((x423*x441))+((x408*x437))+(((-0.055)*x463))+(((-1.0)*x411*x418))+(((-1.0)*gconst3*x415))+(((-1.0)*gconst6*x420))+(((-1.0)*x408*x447))+(((-1.0)*x429*x455))+(((-1.0)*gconst14*x422*x425))+(((-1.0)*gconst3*x409*x418))+(((-1.21)*gconst2*gconst6))+(((-1.0)*gconst0*gconst15*x419))+((x427*x440))+(((-2.695)*sj0*x419))+(((-1.0)*gconst2*x415))+((x422*x423))+((x429*x440))+(((-3.3375)*gconst4*x462))+(((-1.0)*gconst0*gconst4*x467))+((gconst0*gconst13*x442))+(((2.11775)*x462)));
op[7]=((((-1.45)*x410*x445))+(((-1.0)*gconst0*x408*x435))+(((-1.0)*gconst4*x468))+((gconst6*x454))+(((-1.1)*gconst6*x440))+(((-0.33)*x462))+(((1.452)*x445))+(((-1.0)*x439*x440))+(((-2.295)*sj0*x419))+(((-1.1)*gconst2*x408))+((x418*x436))+((x419*x439))+((gconst0*x419*x435))+((x422*x464))+(((-2.295)*x463))+(((1.1)*gconst4*x462))+((x408*x464))+((gconst4*x418*x435))+((x439*x451))+(((-1.0)*gconst4*x435*x440))+(((-1.0)*x408*x436))+((x436*x456))+(((-1.45)*gconst4*sj0*x441))+(((-1.0)*gconst6*x436)));
op[8]=(((x440*x455))+(((-1.0)*x413*x462))+(((-1.0)*gconst2*x408*x425))+((gconst1*gconst6*x428))+((x419*x428))+(((-1.21)*x442))+((x408*x448))+(((-1.0)*x418*x419)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
tj1 = IKtan(j1);
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x477=(cj1*r21);
IkReal x478=(sj4*sj5);
IkReal x479=(cj1*r22);
IkReal x480=((2.59805588659292)*cj5);
IkReal x481=(r21*sj1);
IkReal x482=((8.0)*pz);
IkReal x483=(cj4*sj1);
IkReal x484=(cj1*cj4);
IkReal x485=((0.433012701892219)*cj5);
IkReal x486=(r20*sj1);
IkReal x487=(cj5*sj4);
IkReal x488=(r22*sj1);
IkReal x489=((2.59805588659292)*sj5);
IkReal x490=(r22*x483);
IkReal x491=((1.90525588832577)*cj4*cj5);
IkReal x492=((0.433012701892219)*r20*sj5);
IkReal x493=((1.90525588832577)*r20*sj5);
IkReal x494=(cj1*r20*x487);
if( IKabs(((((3.3)*x490))+(((-1.0)*cj1*x492))+(((1.1)*x488))+(((-1.0)*x483*x493))+(((-0.75)*cj4*x479))+((sj1*x482))+(((0.866025403784439)*x494))+(((-0.25)*x479))+(((-3.81051177665153)*x486*x487))+(((-4.8)*cj1*sj1))+((x480*x481))+(((-1.0)*x477*x485))+(((-1.0)*x481*x491))+((x486*x489))+(((3.81051177665153)*x478*x481))+((x484*x492))+((cj4*x477*x485))+(((-0.866025403784439)*x477*x478)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-4.8)*(cj1*cj1)))+(((-1.0)*x483*x492))+(((-1.0)*cj4*x481*x485))+((x481*x485))+(((0.433012701892219)*sj5*x486))+(((0.25)*x488))+(((3.81051177665153)*x477*x478))+(((-0.866025403784439)*x486*x487))+(((0.866025403784439)*x478*x481))+((cj1*x482))+((cj1*r20*x489))+(((-1.0)*x484*x493))+(((1.1)*x479))+(((-3.81051177665153)*x494))+(((-1.0)*x477*x491))+(((0.75)*x490))+(((3.3)*cj4*x479))+((x477*x480)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.3)*x490))+(((-1.0)*cj1*x492))+(((1.1)*x488))+(((-1.0)*x483*x493))+(((-0.75)*cj4*x479))+((sj1*x482))+(((0.866025403784439)*x494))+(((-0.25)*x479))+(((-3.81051177665153)*x486*x487))+(((-4.8)*cj1*sj1))+((x480*x481))+(((-1.0)*x477*x485))+(((-1.0)*x481*x491))+((x486*x489))+(((3.81051177665153)*x478*x481))+((x484*x492))+((cj4*x477*x485))+(((-0.866025403784439)*x477*x478))))+IKsqr(((((-4.8)*(cj1*cj1)))+(((-1.0)*x483*x492))+(((-1.0)*cj4*x481*x485))+((x481*x485))+(((0.433012701892219)*sj5*x486))+(((0.25)*x488))+(((3.81051177665153)*x477*x478))+(((-0.866025403784439)*x486*x487))+(((0.866025403784439)*x478*x481))+((cj1*x482))+((cj1*r20*x489))+(((-1.0)*x484*x493))+(((1.1)*x479))+(((-3.81051177665153)*x494))+(((-1.0)*x477*x491))+(((0.75)*x490))+(((3.3)*cj4*x479))+((x477*x480))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((3.3)*x490))+(((-1.0)*cj1*x492))+(((1.1)*x488))+(((-1.0)*x483*x493))+(((-0.75)*cj4*x479))+((sj1*x482))+(((0.866025403784439)*x494))+(((-0.25)*x479))+(((-3.81051177665153)*x486*x487))+(((-4.8)*cj1*sj1))+((x480*x481))+(((-1.0)*x477*x485))+(((-1.0)*x481*x491))+((x486*x489))+(((3.81051177665153)*x478*x481))+((x484*x492))+((cj4*x477*x485))+(((-0.866025403784439)*x477*x478))), ((((-4.8)*(cj1*cj1)))+(((-1.0)*x483*x492))+(((-1.0)*cj4*x481*x485))+((x481*x485))+(((0.433012701892219)*sj5*x486))+(((0.25)*x488))+(((3.81051177665153)*x477*x478))+(((-0.866025403784439)*x486*x487))+(((0.866025403784439)*x478*x481))+((cj1*x482))+((cj1*r20*x489))+(((-1.0)*x484*x493))+(((1.1)*x479))+(((-3.81051177665153)*x494))+(((-1.0)*x477*x491))+(((0.75)*x490))+(((3.3)*cj4*x479))+((x477*x480))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
tj2 = IKtan(j2);
{
IkReal evalcond[9];
IkReal x495=IKsin(j2);
IkReal x496=IKcos(j2);
IkReal x497=((0.0865999997833942)*sj5);
IkReal x498=(cj3*r20);
IkReal x499=(r21*sj3);
IkReal x500=(cj5*r01);
IkReal x501=((0.866025403784439)*sj4);
IkReal x502=(cj5*r20);
IkReal x503=(r10*sj3);
IkReal x504=(cj4*cj5);
IkReal x505=(cj4*sj5);
IkReal x506=(r11*sj3);
IkReal x507=(cj0*sj1);
IkReal x508=((0.75)*sj5);
IkReal x509=((0.433012701892219)*cj3);
IkReal x510=((0.433012701892219)*sj5);
IkReal x511=((0.25)*cj3);
IkReal x512=(cj5*r21);
IkReal x513=((1.0)*cj0);
IkReal x514=((0.125)*cj0);
IkReal x515=((0.75)*cj4);
IkReal x516=(sj0*sj1);
IkReal x517=(r01*sj3);
IkReal x518=(r00*sj3);
IkReal x519=(cj5*r11);
IkReal x520=((0.75)*cj3);
IkReal x521=(cj3*r10);
IkReal x522=(cj3*r00);
IkReal x523=((0.125)*sj0);
IkReal x524=((0.5)*cj5*sj4);
IkReal x525=(sj1*x496);
IkReal x526=(cj1*x495);
IkReal x527=((0.5)*sj4*sj5);
IkReal x528=((0.55)*x495);
IkReal x529=(cj1*x496);
IkReal x530=(sj1*x495);
evalcond[0]=((((0.125)*x529))+(((-0.0865999997833942)*x512))+(((0.125)*x530))+(((-1.0)*pz))+(((0.55)*x526))+(((-0.55)*x525))+(((0.6)*cj1))+(((-1.0)*r20*x497)));
evalcond[1]=((((-1.0)*r00*x497))+(((-0.125)*x496*x516))+(((-0.55)*sj0*x529))+(((-0.135)*sj0))+(((-1.0)*px))+(((-1.0)*x516*x528))+((x523*x526))+(((-0.0865999997833942)*x500))+(((-0.6)*x516)));
evalcond[2]=((((-1.0)*r10*x497))+(((-0.0865999997833942)*x519))+(((-1.0)*py))+((x507*x528))+(((0.125)*x496*x507))+(((0.135)*cj0))+(((0.55)*cj0*x529))+(((0.6)*x507))+(((-1.0)*x514*x526)));
evalcond[3]=((((0.433012701892219)*r21*x504))+(((-1.0)*r22*x515))+(((-0.433012701892219)*x512))+(((0.433012701892219)*r20*x505))+(((-1.0)*x526))+((x501*x502))+(((-1.0)*r20*x510))+x525+(((-0.25)*r22))+(((-1.0)*r21*sj5*x501)));
evalcond[4]=((((-1.0)*r00*x510))+((sj0*x529))+(((0.433012701892219)*cj4*x500))+(((-0.25)*r02))+(((-0.433012701892219)*x500))+(((-1.0)*r01*sj5*x501))+(((-1.0)*r02*x515))+((x495*x516))+((cj5*r00*x501))+(((0.433012701892219)*r00*x505)));
evalcond[5]=((((-1.0)*r11*sj5*x501))+(((-0.433012701892219)*x519))+(((-0.25)*r12))+(((-1.0)*r12*x515))+(((-1.0)*x495*x507))+(((0.433012701892219)*r11*x504))+(((-1.0)*x513*x529))+((cj5*r10*x501))+(((-1.0)*r10*x510))+(((0.433012701892219)*r10*x505)));
evalcond[6]=((((-1.0)*r22*sj3*x501))+(((-1.0)*r22*x509))+((cj3*r21*x527))+(((-0.25)*x498*x505))+x530+x529+(((-1.0)*r21*x504*x511))+(((-1.0)*x512*x520))+(((-1.0)*cj4*sj3*x502))+((x499*x524))+(((-1.0)*x498*x524))+((r20*sj3*x527))+((cj4*r22*x509))+((x499*x505))+(((-1.0)*x498*x508)));
evalcond[7]=(((cj4*r02*x509))+(((-1.0)*x500*x520))+((sj0*x526))+(((-1.0)*x504*x518))+((cj3*r01*x527))+((x518*x527))+(((-1.0)*r02*sj3*x501))+(((-1.0)*x508*x522))+(((-1.0)*x496*x516))+(((-1.0)*r00*x505*x511))+(((-1.0)*cj4*x500*x511))+(((0.5)*sj3*sj4*x500))+(((-1.0)*x522*x524))+((x505*x517))+(((-1.0)*r02*x509)));
evalcond[8]=((((-1.0)*x521*x524))+((x505*x506))+(((-1.0)*r12*sj3*x501))+((x503*x527))+((x496*x507))+(((-1.0)*x508*x521))+((cj4*r12*x509))+((x506*x524))+(((-1.0)*r10*x505*x511))+(((-1.0)*x513*x526))+(((-1.0)*r12*x509))+(((-1.0)*r11*x504*x511))+((cj3*r11*x527))+(((-1.0)*x519*x520))+(((-1.0)*x503*x504)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x531=(cj0*cj5);
IkReal x532=(cj0*r22);
IkReal x533=(cj0*sj5);
IkReal x534=(cj4*r20);
IkReal x535=((0.5)*sj4);
IkReal x536=((0.866025403784439)*sj4);
IkReal x537=((0.433012701892219)*cj5);
IkReal x538=(cj4*r21);
IkReal x539=((0.433012701892219)*sj5);
CheckValue<IkReal> x540=IKPowWithIntegerCheck(IKsign((((r10*((x539+(((-1.0)*cj4*x539))+(((-1.0)*cj5*x536))))))+((r11*((((sj5*x536))+x537+(((-1.0)*cj4*x537))))))+((r12*(((0.25)+(((0.75)*cj4)))))))),-1);
if(!x540.valid){
continue;
}
CheckValue<IkReal> x541 = IKatan2WithCheck(IkReal(((((-1.0)*x532*x536))+((r21*x531*x535))+(((-1.0)*x531*x534))+((r20*x533*x535))+((x533*x538)))),IkReal(((((0.433012701892219)*cj4*x532))+(((-0.75)*r20*x533))+(((-0.25)*x533*x534))+(((-0.25)*x531*x538))+((r21*x533*x535))+(((-1.0)*r20*x531*x535))+(((-0.75)*r21*x531))+(((-0.433012701892219)*x532)))),IKFAST_ATAN2_MAGTHRESH);
if(!x541.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x540.value)))+(x541.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
tj3 = IKtan(j3);
{
IkReal evalcond[3];
IkReal x542=IKsin(j3);
IkReal x543=IKcos(j3);
IkReal x544=((0.5)*sj4);
IkReal x545=((1.0)*cj4);
IkReal x546=((0.25)*cj4);
IkReal x547=((0.433012701892219)*x542);
IkReal x548=(cj5*x542);
IkReal x549=(sj5*x542);
IkReal x550=(sj5*x543);
IkReal x551=(cj5*x543);
IkReal x552=((0.866025403784439)*sj4*x543);
evalcond[0]=(((r20*x546*x549))+(((-1.0)*r22*x552))+((r21*x546*x548))+(((-1.0)*r20*x545*x551))+(((-1.0)*r21*x544*x549))+((r22*x547))+((cj4*r21*x550))+(((-1.0)*cj4*r22*x547))+(((0.75)*r21*x548))+((r20*x544*x550))+((r20*x544*x548))+(((0.75)*r20*x549))+((r21*x544*x551)));
evalcond[1]=(((r00*x546*x549))+((r01*x544*x551))+((r00*x544*x550))+((r00*x544*x548))+cj0+((r02*x547))+((r01*x546*x548))+(((-1.0)*r02*x552))+(((0.75)*r00*x549))+(((-1.0)*r01*x544*x549))+(((-1.0)*cj4*r02*x547))+(((0.75)*r01*x548))+((cj4*r01*x550))+(((-1.0)*r00*x545*x551)));
evalcond[2]=((((-1.0)*r12*x552))+sj0+((r11*x544*x551))+(((-1.0)*r11*x544*x549))+((r12*x547))+(((-1.0)*r10*x545*x551))+(((0.75)*r10*x549))+((cj4*r11*x550))+((r10*x546*x549))+((r10*x544*x550))+((r10*x544*x548))+(((-1.0)*cj4*r12*x547))+((r11*x546*x548))+(((0.75)*r11*x548)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[8+1], zeror[8];
int numroots;
IkReal x553=((1.0)*px);
IkReal x554=((0.0865999997833942)*sj5);
IkReal x555=((0.0865999997833942)*cj5);
IkReal x556=(r01*x555);
IkReal x557=(r00*x554);
IkReal x558=(((r20*x554))+(((1.0)*pz))+((r21*x555)));
IkReal x559=((0.725)+(((-1.0)*x558)));
IkReal x560=((0.475)+(((-1.0)*x558)));
IkReal x561=((-0.725)+(((-1.0)*x558)));
IkReal x562=((-0.475)+(((-1.0)*x558)));
IkReal x563=(x553+x557+x556);
IkReal x564=((((0.415)*sj0))+(((-1.0)*x563)));
IkReal x565=((((-0.685)*sj0))+(((-1.0)*x563)));
IkReal gconst0=x559;
IkReal gconst1=x560;
IkReal gconst2=x565;
IkReal gconst3=x564;
IkReal gconst4=x559;
IkReal gconst5=x560;
IkReal gconst6=x565;
IkReal gconst7=x564;
IkReal gconst8=x561;
IkReal gconst9=x562;
IkReal gconst10=x564;
IkReal gconst11=x565;
IkReal gconst12=x561;
IkReal gconst13=x562;
IkReal gconst14=x564;
IkReal gconst15=x565;
IkReal x566=sj0*sj0;
IkReal x567=(gconst0*gconst11);
IkReal x568=(gconst5*gconst6);
IkReal x569=((1.0)*gconst12);
IkReal x570=(gconst0*gconst5);
IkReal x571=((1.045)*sj0);
IkReal x572=(gconst14*gconst8);
IkReal x573=((0.0625)*gconst4);
IkReal x574=(gconst13*gconst14);
IkReal x575=((1.21)*gconst7);
IkReal x576=(gconst13*sj0);
IkReal x577=(gconst10*gconst9);
IkReal x578=(gconst0*gconst7);
IkReal x579=(gconst3*gconst4);
IkReal x580=((1.4795)*sj0);
IkReal x581=(gconst11*gconst8);
IkReal x582=(gconst2*gconst5);
IkReal x583=((1.595)*sj0);
IkReal x584=(gconst11*sj0);
IkReal x585=((1.0)*gconst1);
IkReal x586=((1.21)*gconst11);
IkReal x587=(gconst15*gconst4);
IkReal x588=((0.275)*sj0);
IkReal x589=((2.64)*sj0);
IkReal x590=(gconst11*gconst14);
IkReal x591=(gconst9*sj0);
IkReal x592=((1.0)*gconst7);
IkReal x593=(gconst10*gconst15);
IkReal x594=((1.1)*gconst12);
IkReal x595=((0.95)*sj0);
IkReal x596=((1.1)*gconst3);
IkReal x597=(gconst3*gconst8);
IkReal x598=(gconst15*gconst9);
IkReal x599=((1.1)*gconst7);
IkReal x600=(gconst1*gconst2);
IkReal x601=(gconst1*gconst7);
IkReal x602=(gconst3*gconst6);
IkReal x603=((1.1)*gconst11);
IkReal x604=((0.0625)*gconst12);
IkReal x605=(gconst3*sj0);
IkReal x606=(gconst12*gconst8);
IkReal x607=(gconst2*gconst9);
IkReal x608=(gconst0*gconst3);
IkReal x609=(gconst13*gconst6);
IkReal x610=((1.21)*gconst14);
IkReal x611=(gconst2*gconst4);
IkReal x612=((1.1)*gconst15);
IkReal x613=(gconst12*gconst15);
IkReal x614=((1.452)*sj0);
IkReal x615=(gconst4*gconst7);
IkReal x616=(gconst0*gconst6);
IkReal x617=(gconst12*gconst7);
IkReal x618=(gconst6*x586);
IkReal x619=(gconst3*x610);
IkReal x620=((1.7424)*x566);
IkReal x621=((1.3775)*x566);
IkReal x622=(gconst1*x566);
IkReal x623=(gconst1*gconst6*sj0);
IkReal x624=((1.45)*gconst1*sj0);
IkReal x625=(gconst9*x566);
IkReal x626=((3.39025)*x566);
IkReal x627=((0.9025)*x566);
IkReal x628=((0.33)*x566);
IkReal x629=(gconst12*gconst3*x588);
IkReal x630=(gconst1*gconst14*x588);
IkReal x631=((0.275)*gconst4*x584);
IkReal x632=(gconst6*gconst9*x588);
IkReal x633=(x573*x625);
IkReal x634=(x604*x622);
IkReal x635=(x629+x632+x630+x631);
IkReal x636=(x618+x619+x620+x634+x633);
op[0]=((((-1.0)*x604*x625))+(((0.275)*gconst12*x584))+(((-1.0)*gconst15*x569*x581))+((gconst11*gconst13*x572))+(((-1.0)*gconst14*x586))+((gconst14*gconst9*x588))+((x577*x613))+(((-1.0)*x574*x577)));
op[1]=(((x572*x603))+(((2.295)*gconst12*x584))+((gconst14*x614))+((x581*x612))+(((-1.1)*gconst10*x574))+(((1.1)*x590))+(((-1.0)*x594*x625))+(((-0.95)*x572*x576))+(((-1.0)*x574*x603))+(((-1.45)*x591*x613))+((gconst15*x595*x606))+(((-1.0)*gconst12*x628))+(((-1.1)*gconst14*x577))+(((-1.0)*x577*x612))+((gconst11*gconst15*x594))+(((1.45)*x576*x577))+(((-0.33)*x625))+(((-1.45)*x576*x581))+((gconst12*x581*x595))+(((1.452)*x584))+(((2.295)*gconst14*x591))+((x593*x594))+(((-1.0)*gconst12*x577*x595))+(((1.45)*x574*x591)));
op[2]=((((-1.0)*gconst10*gconst12*x571))+(((-1.0)*x581*x587))+((gconst1*gconst12*x593))+(((-1.0)*gconst10*x610))+(((-2.1025)*gconst13*x625))+((x577*x589))+((x577*x587))+((x567*x574))+(((-1.0)*x589*x613))+((gconst12*gconst2*x598))+(((-1.0)*gconst15*x567*x569))+(((-1.0)*gconst15*x569*x597))+((gconst11*gconst5*x572))+(((-1.0)*x574*x607))+(((-1.0)*gconst15*x586))+(((-1.0)*x606*x627))+(((-1.0)*x571*x572))+(((-2.11775)*x625))+(((-0.055)*gconst14*x591))+(((-1.0)*x636))+(((1.595)*gconst11*x576))+((x581*x609))+((gconst13*gconst8*x621))+(((-1.21)*x593))+((x574*x589))+(((1.595)*gconst10*x576))+(((-1.0)*gconst12*x626))+(((-2.695)*gconst12*x584))+((x583*x598))+x635+(((-1.0)*x577*x609))+(((0.96)*x590))+(((-1.0)*gconst10*x574*x585))+(((-1.0)*gconst14*gconst5*x577))+((gconst14*x580))+(((-1.0)*gconst7*x569*x581))+(((-4.1195)*x584))+(((-1.0)*gconst15*gconst8*x571))+((gconst13*gconst3*x572))+((x577*x617))+(((-3.3375)*gconst12*x625))+(((-1.0)*x581*x589)));
op[3]=((((-0.95)*gconst0*gconst13*gconst14*sj0))+(((1.584)*(sj0*sj0)))+(((2.295)*gconst6*gconst9*sj0))+(((-1.45)*gconst0*gconst11*gconst13*sj0))+(((1.1)*gconst12*gconst15*gconst3))+(((1.1)*gconst12*gconst15*gconst2))+(((-1.45)*gconst11*gconst5*gconst8*sj0))+(((-0.95)*gconst1*gconst10*gconst12*sj0))+(((-1.1)*gconst13*gconst14*gconst2))+(((-1.1)*gconst13*gconst14*gconst3))+(((2.295)*gconst11*gconst4*sj0))+(((2.904)*gconst10*sj0))+(((1.1)*gconst11*gconst6*gconst8))+(((-1.1)*gconst11*gconst13*gconst6))+(((2.508)*gconst8*(sj0*sj0)))+(((-1.1)*gconst10*gconst6*gconst9))+(((-0.33)*gconst4*(sj0*sj0)))+(((0.95)*gconst11*gconst4*gconst8*sj0))+(((-1.45)*gconst1*gconst12*gconst15*sj0))+(((-1.1)*gconst14*gconst2*gconst9))+(((-2.295)*gconst14*gconst9*sj0))+(((1.1)*gconst11*gconst6))+(((-1.45)*gconst13*gconst3*gconst8*sj0))+(((0.95)*gconst15*gconst4*gconst8*sj0))+(((1.45)*gconst1*gconst13*gconst14*sj0))+(((-1.1)*gconst10*gconst14*gconst5))+(((0.95)*gconst12*gconst7*gconst8*sj0))+(((-1.45)*gconst12*gconst7*gconst9*sj0))+(((2.295)*gconst1*gconst14*sj0))+(((1.45)*gconst13*gconst6*gconst9*sj0))+(((-0.95)*gconst13*gconst6*gconst8*sj0))+(((1.45)*gconst10*gconst5*gconst9*sj0))+(((-0.9725)*gconst14*sj0))+(((1.1)*gconst0*gconst11*gconst14))+(((1.1)*gconst0*gconst11*gconst15))+(((-1.1)*gconst11*gconst14))+(((1.1)*gconst11*gconst12*gconst7))+(((1.1)*gconst11*gconst15*gconst4))+(((1.45)*gconst14*gconst5*gconst9*sj0))+(((3.751)*gconst9*(sj0*sj0)))+(((-1.1)*gconst4*gconst9*(sj0*sj0)))+(((-1.1)*gconst1*gconst12*(sj0*sj0)))+(((-1.45)*gconst15*gconst4*gconst9*sj0))+(((1.452)*gconst6*sj0))+(((-1.1)*gconst10*gconst13*gconst6))+(((-1.1)*gconst11*gconst14*gconst5))+(((0.95)*gconst12*gconst3*gconst8*sj0))+(((2.904)*gconst15*sj0))+(((-0.95)*gconst14*gconst5*gconst8*sj0))+(((1.45)*gconst13*gconst2*gconst9*sj0))+(((-0.95)*gconst10*gconst4*gconst9*sj0))+(((2.295)*gconst12*gconst3*sj0))+(((-1.1)*gconst10*gconst7*gconst9))+(((1.452)*gconst3*sj0))+(((1.1)*gconst10*gconst12*gconst7))+(((-0.33)*gconst1*(sj0*sj0)))+(((1.1)*gconst12*gconst9*(sj0*sj0)))+(((0.95)*gconst0*gconst11*gconst12*sj0))+(((1.5725)*gconst11*sj0))+(((1.1)*gconst10*gconst15*gconst4))+(((1.1)*gconst15*gconst3*gconst8))+(((0.95)*gconst0*gconst12*gconst15*sj0))+(((-1.111)*gconst12*(sj0*sj0)))+(((1.1)*gconst14*gconst3*gconst8))+(((-1.1)*gconst15*gconst2*gconst9))+(((1.1)*gconst14*gconst3))+(((-3.828)*gconst13*(sj0*sj0)))+(((-0.95)*gconst12*gconst2*gconst9*sj0))+(((1.45)*gconst1*gconst10*gconst13*sj0))+(((-2.295)*gconst11*gconst12*sj0))+(((1.1)*gconst11*gconst7*gconst8))+(((-1.1)*gconst1*gconst10*gconst14))+(((-1.1)*gconst1*gconst10*gconst15)));
op[4]=((((-1.0)*gconst0*gconst11*gconst12*gconst7))+(((-2.64)*gconst12*gconst7*sj0))+(((1.3775)*gconst5*gconst8*(sj0*sj0)))+((gconst1*gconst10*gconst12*gconst7))+(((0.275)*gconst3*gconst4*sj0))+(((1.4795)*gconst6*sj0))+(((1.595)*gconst7*gconst9*sj0))+(((0.96)*gconst11*gconst6))+(((-1.0)*gconst1*gconst10*gconst13*gconst6))+(((-2.1025)*gconst5*gconst9*(sj0*sj0)))+(((1.595)*gconst11*gconst5*sj0))+((gconst11*gconst5*gconst6*gconst8))+(((-0.0625)*gconst12*gconst9*(sj0*sj0)))+(((0.96)*gconst14*gconst3))+(((-1.0)*gconst0*gconst12*gconst15*gconst3))+(((2.64)*gconst13*gconst6*sj0))+((gconst0*gconst11*gconst14*gconst5))+(((4.1195)*gconst11*sj0))+((gconst12*gconst2*gconst7*gconst9))+(((-1.4795)*gconst14*sj0))+(((-1.0)*gconst12*gconst3*gconst7*gconst8))+(((-0.055)*gconst6*gconst9*sj0))+(((-3.3375)*gconst1*gconst12*(sj0*sj0)))+(((3.39025)*gconst12*(sj0*sj0)))+(((1.3775)*gconst0*gconst13*(sj0*sj0)))+(((-1.0)*gconst10*gconst5*gconst6*gconst9))+(((2.64)*gconst2*gconst9*sj0))+(((-1.0)*gconst14*gconst2*gconst5*gconst9))+(((0.275)*gconst14*gconst9*sj0))+(((0.275)*gconst1*gconst6*sj0))+(((-0.0625)*gconst1*gconst4*(sj0*sj0)))+(((-1.0)*gconst13*gconst2*gconst6*gconst9))+(((-1.21)*gconst15*gconst2))+(((-1.21)*gconst15*gconst3))+(((0.275)*gconst11*gconst12*sj0))+(((1.595)*gconst13*gconst3*sj0))+(((2.64)*gconst14*gconst5*sj0))+(((-0.055)*gconst1*gconst14*sj0))+(((2.64)*gconst1*gconst10*sj0))+(((1.595)*gconst13*gconst2*sj0))+(((-0.9025)*gconst4*gconst8*(sj0*sj0)))+((gconst15*gconst2*gconst4*gconst9))+((gconst10*gconst4*gconst7*gconst9))+((gconst0*gconst13*gconst14*gconst3))+(((-0.9025)*gconst0*gconst12*(sj0*sj0)))+(((-2.64)*gconst0*gconst11*sj0))+(((-2.11775)*gconst1*(sj0*sj0)))+((gconst0*gconst11*gconst13*gconst6))+(((-1.21)*gconst14*gconst2))+(((-1.21)*gconst3*gconst6))+(((1.595)*gconst10*gconst5*sj0))+(((2.632225)*(sj0*sj0)))+(((-1.045)*gconst12*gconst2*sj0))+((gconst1*gconst10*gconst15*gconst4))+(((-1.045)*gconst7*gconst8*sj0))+(((-1.0)*gconst1*gconst13*gconst14*gconst2))+(((-1.045)*gconst0*gconst15*sj0))+(((-4.1195)*gconst3*sj0))+(((-3.39025)*gconst4*(sj0*sj0)))+(((-2.64)*gconst15*gconst4*sj0))+((gconst14*gconst3*gconst5*gconst8))+(((1.595)*gconst1*gconst15*sj0))+(((-1.045)*gconst10*gconst4*sj0))+(((-1.045)*gconst6*gconst8*sj0))+(((-2.64)*gconst3*gconst8*sj0))+(((-1.0)*gconst0*gconst11*gconst15*gconst4))+(((-2.695)*gconst11*gconst4*sj0))+((gconst13*gconst3*gconst6*gconst8))+((gconst1*gconst12*gconst15*gconst2))+(((-1.045)*gconst0*gconst14*sj0))+(((-1.21)*gconst11*gconst14))+(((-1.21)*gconst10*gconst7))+(((-1.21)*gconst10*gconst6))+(((-2.695)*gconst12*gconst3*sj0))+(((2.11775)*gconst9*(sj0*sj0)))+(((-3.3375)*gconst4*gconst9*(sj0*sj0)))+(((-1.0)*gconst1*gconst10*gconst14*gconst5))+(((-2.1025)*gconst1*gconst13*(sj0*sj0)))+(((-1.21)*gconst11*gconst7))+(((-1.0)*gconst11*gconst4*gconst7*gconst8))+(((-1.0)*gconst15*gconst3*gconst4*gconst8)));
op[5]=((((-1.1)*gconst11*gconst5*gconst6))+(((1.45)*gconst1*gconst14*gconst5*sj0))+(((-1.45)*gconst3*gconst5*gconst8*sj0))+(((-1.1)*gconst13*gconst3*gconst6))+(((-1.1)*gconst2*gconst7*gconst9))+(((-2.295)*gconst12*gconst3*sj0))+(((1.45)*gconst5*gconst6*gconst9*sj0))+(((-0.95)*gconst5*gconst6*gconst8*sj0))+(((-1.111)*gconst4*(sj0*sj0)))+(((-0.33)*gconst9*(sj0*sj0)))+(((2.904)*gconst7*sj0))+(((1.1)*gconst15*gconst2*gconst4))+(((-1.1)*gconst1*gconst4*(sj0*sj0)))+(((-1.1)*gconst14*gconst2*gconst5))+(((3.751)*gconst1*(sj0*sj0)))+(((1.45)*gconst1*gconst13*gconst2*sj0))+(((-0.33)*gconst12*(sj0*sj0)))+(((0.95)*gconst0*gconst15*gconst4*sj0))+(((2.904)*gconst2*sj0))+(((-1.1)*gconst13*gconst2*gconst6))+(((1.1)*gconst0*gconst14*gconst3))+(((-1.1)*gconst1*gconst10*gconst6))+(((-1.1)*gconst1*gconst10*gconst7))+(((-1.45)*gconst4*gconst7*gconst9*sj0))+(((-2.295)*gconst11*gconst4*sj0))+(((1.5725)*gconst3*sj0))+(((1.1)*gconst3*gconst6))+(((1.45)*gconst1*gconst13*gconst6*sj0))+(((0.95)*gconst0*gconst12*gconst3*sj0))+(((1.45)*gconst1*gconst10*gconst5*sj0))+(((-1.1)*gconst14*gconst3*gconst5))+(((-2.295)*gconst1*gconst14*sj0))+(((-1.1)*gconst2*gconst6*gconst9))+(((1.1)*gconst0*gconst11*gconst6))+(((1.1)*gconst0*gconst11*gconst7))+(((-0.95)*gconst1*gconst12*gconst2*sj0))+(((-1.584)*(sj0*sj0)))+(((-1.1)*gconst11*gconst6))+(((1.1)*gconst11*gconst4*gconst7))+(((-3.828)*gconst5*(sj0*sj0)))+(((-2.295)*gconst6*gconst9*sj0))+(((-0.95)*gconst0*gconst14*gconst5*sj0))+(((1.1)*gconst0*gconst15*gconst3))+(((1.45)*gconst2*gconst5*gconst9*sj0))+(((-0.9725)*gconst6*sj0))+(((-1.45)*gconst1*gconst12*gconst7*sj0))+(((0.95)*gconst0*gconst12*gconst7*sj0))+(((-1.1)*gconst1*gconst14*gconst2))+(((1.1)*gconst10*gconst4*gconst7))+(((2.295)*gconst3*gconst4*sj0))+(((1.1)*gconst1*gconst12*(sj0*sj0)))+(((1.452)*gconst11*sj0))+(((-0.95)*gconst2*gconst4*gconst9*sj0))+(((2.508)*gconst0*(sj0*sj0)))+(((-1.45)*gconst1*gconst15*gconst4*sj0))+(((1.1)*gconst4*gconst9*(sj0*sj0)))+(((-1.1)*gconst1*gconst15*gconst2))+(((-1.1)*gconst10*gconst5*gconst6))+(((1.1)*gconst3*gconst6*gconst8))+(((0.95)*gconst4*gconst7*gconst8*sj0))+(((-1.45)*gconst0*gconst11*gconst5*sj0))+(((1.1)*gconst3*gconst7*gconst8))+(((1.1)*gconst12*gconst2*gconst7))+(((0.95)*gconst0*gconst11*gconst4*sj0))+(((2.295)*gconst1*gconst6*sj0))+(((1.452)*gconst14*sj0))+(((-0.95)*gconst0*gconst13*gconst6*sj0))+(((1.1)*gconst15*gconst3*gconst4))+(((-1.45)*gconst0*gconst13*gconst3*sj0))+(((-1.1)*gconst14*gconst3))+(((-0.95)*gconst1*gconst10*gconst4*sj0))+(((1.1)*gconst12*gconst3*gconst7))+(((0.95)*gconst3*gconst4*gconst8*sj0)));
op[6]=((((-1.0)*gconst10*x568*x585))+((x570*x621))+((x600*x617))+(((-2.1025)*gconst5*x622))+(((-0.055)*x623))+(((-1.0)*x589*x615))+((x582*x583))+(((-2.695)*sj0*x579))+(((-1.0)*x571*x616))+(((-1.0)*x571*x611))+((gconst0*gconst13*x602))+((x589*x600))+(((-1.0)*gconst8*x579*x592))+(((-1.0)*x571*x578))+(((-1.0)*x636))+(((-1.0)*x589*x608))+(((-1.0)*gconst14*x582*x585))+(((-1.0)*gconst0*gconst4*x627))+(((-1.0)*gconst4*x567*x592))+((gconst14*gconst3*x570))+((x567*x568))+((gconst4*x626))+((x568*x597))+(((-1.0)*gconst0*gconst15*x579))+(((-3.3375)*gconst4*x622))+(((0.96)*x602))+((x607*x615))+((gconst10*gconst4*x601))+x635+((x587*x600))+(((-1.0)*gconst3*x575))+((gconst3*gconst5*x583))+(((4.1195)*x605))+((x568*x589))+(((-1.21)*gconst2*gconst6))+(((-1.0)*x568*x607))+(((-1.0)*gconst2*x575))+(((-1.0)*gconst2*x585*x609))+(((-1.0)*gconst6*x580))+(((-1.0)*gconst3*x569*x578))+((x583*x601))+(((2.11775)*x622)));
op[7]=((((-2.295)*sj0*x579))+((x568*x624))+(((-1.0)*gconst4*x628))+((gconst6*x614))+(((-2.295)*x623))+((gconst4*x578*x595))+(((-1.1)*gconst2*x568))+((x582*x624))+((x578*x596))+(((-1.1)*gconst6*x600))+(((-1.45)*x570*x605))+(((1.452)*x605))+(((-1.0)*gconst0*x568*x595))+((x579*x599))+(((-1.0)*x599*x600))+(((1.1)*gconst4*x622))+(((-1.0)*gconst6*x596))+(((-0.33)*x622))+(((-1.0)*gconst4*x595*x600))+((x599*x611))+((x596*x616))+((gconst0*x579*x595))+(((-1.0)*x568*x596))+(((-1.45)*gconst4*sj0*x601)));
op[8]=(((x579*x588))+((x600*x615))+(((-1.21)*x602))+((x568*x608))+((gconst1*gconst6*x588))+(((-1.0)*gconst2*x568*x585))+(((-1.0)*x578*x579))+(((-1.0)*x573*x622)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
tj1 = IKtan(j1);
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x637=(cj1*r21);
IkReal x638=(sj4*sj5);
IkReal x639=(cj1*r22);
IkReal x640=((2.59805588659292)*cj5);
IkReal x641=(r21*sj1);
IkReal x642=((8.0)*pz);
IkReal x643=(cj4*sj1);
IkReal x644=(cj1*cj4);
IkReal x645=((0.433012701892219)*cj5);
IkReal x646=(r20*sj1);
IkReal x647=(cj5*sj4);
IkReal x648=(r22*sj1);
IkReal x649=((2.59805588659292)*sj5);
IkReal x650=(r22*x643);
IkReal x651=((1.90525588832577)*cj4*cj5);
IkReal x652=((0.433012701892219)*r20*sj5);
IkReal x653=((1.90525588832577)*r20*sj5);
IkReal x654=(cj1*r20*x647);
if( IKabs(((((-1.0)*x641*x651))+(((-3.81051177665153)*x646*x647))+(((-1.0)*cj1*x652))+((sj1*x642))+((x644*x652))+(((3.81051177665153)*x638*x641))+((x640*x641))+(((-0.75)*cj4*x639))+(((-4.8)*cj1*sj1))+(((-1.0)*x643*x653))+(((3.3)*x650))+(((-1.0)*x637*x645))+(((-0.25)*x639))+(((-0.866025403784439)*x637*x638))+((x646*x649))+(((0.866025403784439)*x654))+(((1.1)*x648))+((cj4*x637*x645)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.433012701892219)*sj5*x646))+(((-4.8)*(cj1*cj1)))+(((0.25)*x648))+(((-1.0)*cj4*x641*x645))+(((1.1)*x639))+(((3.81051177665153)*x637*x638))+((x637*x640))+((cj1*x642))+((x641*x645))+(((-1.0)*x643*x652))+(((-3.81051177665153)*x654))+(((3.3)*cj4*x639))+(((-1.0)*x644*x653))+(((0.75)*x650))+((cj1*r20*x649))+(((-0.866025403784439)*x646*x647))+(((0.866025403784439)*x638*x641))+(((-1.0)*x637*x651)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x641*x651))+(((-3.81051177665153)*x646*x647))+(((-1.0)*cj1*x652))+((sj1*x642))+((x644*x652))+(((3.81051177665153)*x638*x641))+((x640*x641))+(((-0.75)*cj4*x639))+(((-4.8)*cj1*sj1))+(((-1.0)*x643*x653))+(((3.3)*x650))+(((-1.0)*x637*x645))+(((-0.25)*x639))+(((-0.866025403784439)*x637*x638))+((x646*x649))+(((0.866025403784439)*x654))+(((1.1)*x648))+((cj4*x637*x645))))+IKsqr(((((0.433012701892219)*sj5*x646))+(((-4.8)*(cj1*cj1)))+(((0.25)*x648))+(((-1.0)*cj4*x641*x645))+(((1.1)*x639))+(((3.81051177665153)*x637*x638))+((x637*x640))+((cj1*x642))+((x641*x645))+(((-1.0)*x643*x652))+(((-3.81051177665153)*x654))+(((3.3)*cj4*x639))+(((-1.0)*x644*x653))+(((0.75)*x650))+((cj1*r20*x649))+(((-0.866025403784439)*x646*x647))+(((0.866025403784439)*x638*x641))+(((-1.0)*x637*x651))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x641*x651))+(((-3.81051177665153)*x646*x647))+(((-1.0)*cj1*x652))+((sj1*x642))+((x644*x652))+(((3.81051177665153)*x638*x641))+((x640*x641))+(((-0.75)*cj4*x639))+(((-4.8)*cj1*sj1))+(((-1.0)*x643*x653))+(((3.3)*x650))+(((-1.0)*x637*x645))+(((-0.25)*x639))+(((-0.866025403784439)*x637*x638))+((x646*x649))+(((0.866025403784439)*x654))+(((1.1)*x648))+((cj4*x637*x645))), ((((0.433012701892219)*sj5*x646))+(((-4.8)*(cj1*cj1)))+(((0.25)*x648))+(((-1.0)*cj4*x641*x645))+(((1.1)*x639))+(((3.81051177665153)*x637*x638))+((x637*x640))+((cj1*x642))+((x641*x645))+(((-1.0)*x643*x652))+(((-3.81051177665153)*x654))+(((3.3)*cj4*x639))+(((-1.0)*x644*x653))+(((0.75)*x650))+((cj1*r20*x649))+(((-0.866025403784439)*x646*x647))+(((0.866025403784439)*x638*x641))+(((-1.0)*x637*x651))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
tj2 = IKtan(j2);
{
IkReal evalcond[9];
IkReal x655=IKsin(j2);
IkReal x656=IKcos(j2);
IkReal x657=((0.0865999997833942)*sj5);
IkReal x658=(cj3*r20);
IkReal x659=(r21*sj3);
IkReal x660=(cj5*r01);
IkReal x661=((0.866025403784439)*sj4);
IkReal x662=(cj5*r20);
IkReal x663=(r10*sj3);
IkReal x664=(cj4*cj5);
IkReal x665=(cj4*sj5);
IkReal x666=(r11*sj3);
IkReal x667=(cj0*sj1);
IkReal x668=((0.75)*sj5);
IkReal x669=((0.433012701892219)*cj3);
IkReal x670=((0.433012701892219)*sj5);
IkReal x671=((0.25)*cj3);
IkReal x672=(cj5*r21);
IkReal x673=((1.0)*cj0);
IkReal x674=((0.125)*cj0);
IkReal x675=((0.75)*cj4);
IkReal x676=(sj0*sj1);
IkReal x677=(r01*sj3);
IkReal x678=(r00*sj3);
IkReal x679=(cj5*r11);
IkReal x680=((0.75)*cj3);
IkReal x681=(cj3*r10);
IkReal x682=(cj3*r00);
IkReal x683=((0.125)*sj0);
IkReal x684=((0.5)*cj5*sj4);
IkReal x685=(sj1*x656);
IkReal x686=(cj1*x655);
IkReal x687=((0.5)*sj4*sj5);
IkReal x688=((0.55)*x655);
IkReal x689=(cj1*x656);
IkReal x690=(sj1*x655);
evalcond[0]=((((0.125)*x689))+(((0.55)*x686))+(((-1.0)*pz))+(((-1.0)*r20*x657))+(((-0.55)*x685))+(((0.6)*cj1))+(((-0.0865999997833942)*x672))+(((0.125)*x690)));
evalcond[1]=((((-0.125)*x656*x676))+(((-1.0)*r00*x657))+((x683*x686))+(((-0.0865999997833942)*x660))+(((-0.135)*sj0))+(((-1.0)*px))+(((-0.55)*sj0*x689))+(((-0.6)*x676))+(((-1.0)*x676*x688)));
evalcond[2]=((((0.55)*cj0*x689))+(((0.6)*x667))+(((-1.0)*py))+((x667*x688))+(((-1.0)*r10*x657))+(((0.135)*cj0))+(((-1.0)*x674*x686))+(((0.125)*x656*x667))+(((-0.0865999997833942)*x679)));
evalcond[3]=((((-1.0)*r22*x675))+(((-1.0)*r20*x670))+(((0.433012701892219)*r21*x664))+(((-1.0)*r21*sj5*x661))+((x661*x662))+(((0.433012701892219)*r20*x665))+x685+(((-0.25)*r22))+(((-0.433012701892219)*x672))+(((-1.0)*x686)));
evalcond[4]=((((-1.0)*r02*x675))+(((0.433012701892219)*cj4*x660))+(((-0.25)*r02))+((x655*x676))+((cj5*r00*x661))+(((0.433012701892219)*r00*x665))+(((-0.433012701892219)*x660))+(((-1.0)*r01*sj5*x661))+((sj0*x689))+(((-1.0)*r00*x670)));
evalcond[5]=(((cj5*r10*x661))+(((0.433012701892219)*r11*x664))+(((0.433012701892219)*r10*x665))+(((-0.25)*r12))+(((-1.0)*r11*sj5*x661))+(((-1.0)*x673*x689))+(((-0.433012701892219)*x679))+(((-1.0)*r10*x670))+(((-1.0)*r12*x675))+(((-1.0)*x655*x667)));
evalcond[6]=(((x659*x684))+(((-1.0)*r22*x669))+(((-1.0)*x658*x684))+(((-1.0)*x658*x668))+((cj3*r21*x687))+(((-0.25)*x658*x665))+x689+x690+(((-1.0)*r21*x664*x671))+((x659*x665))+(((-1.0)*r22*sj3*x661))+(((-1.0)*x672*x680))+(((-1.0)*cj4*sj3*x662))+((cj4*r22*x669))+((r20*sj3*x687)));
evalcond[7]=(((x678*x687))+(((-1.0)*r02*sj3*x661))+((x665*x677))+(((0.5)*sj3*sj4*x660))+(((-1.0)*x656*x676))+((cj4*r02*x669))+(((-1.0)*x668*x682))+(((-1.0)*cj4*x660*x671))+(((-1.0)*x664*x678))+(((-1.0)*x660*x680))+((cj3*r01*x687))+(((-1.0)*x682*x684))+((sj0*x686))+(((-1.0)*r02*x669))+(((-1.0)*r00*x665*x671)));
evalcond[8]=(((x663*x687))+(((-1.0)*x681*x684))+((x665*x666))+(((-1.0)*r10*x665*x671))+((cj4*r12*x669))+(((-1.0)*x668*x681))+((x656*x667))+(((-1.0)*x679*x680))+(((-1.0)*r12*sj3*x661))+(((-1.0)*r12*x669))+(((-1.0)*x663*x664))+((x666*x684))+((cj3*r11*x687))+(((-1.0)*x673*x686))+(((-1.0)*r11*x664*x671)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "6a8b59416fa54a6a6ab1cc45f26e4fda"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004c"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
