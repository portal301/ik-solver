/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004b generated on 2025-11-25 10:17:17.317143
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#define IKFAST_NAMESPACE kj125_ikfast
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004b);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
// Modern MSVC with C++17: use standard math functions (no compat macros needed)
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.03) // 5D IK has some crazy degenerate cases, but can rely on jacobian refinment to make better, just need good starting point
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

template <typename T> struct ComplexLess
{
    bool operator()(const complex<T>& lhs, const complex<T>& rhs) const
    {
        if (real(lhs) < real(rhs)) {
            return true;
        }
        if (real(lhs) > real(rhs)) {
            return false;
        }
        return imag(lhs) < imag(rhs);
    }
};

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70,x71,x72,x73,x74,x75,x76,x77,x78,x79,x80,x81,x82,x83,x84,x85,x86,x87,x88,x89,x90,x91,x92,x93;
x0=IKsin(j[0]);
x1=IKsin(j[1]);
x2=IKsin(j[2]);
x3=IKcos(j[1]);
x4=IKcos(j[2]);
x5=IKcos(j[3]);
x6=IKsin(j[3]);
x7=IKcos(j[0]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=IKsin(j[5]);
x11=IKcos(j[5]);
x12=((0.25)*x7);
x13=((1.0)*x6);
x14=((0.75)*x5);
x15=((0.0736444)*x8);
x16=((0.0567)*x7);
x17=((0.5)*x7);
x18=((0.125)*x7);
x19=((0.5)*x5);
x20=((0.433012701892219)*x7);
x21=((0.866025403784439)*x9);
x22=((0.0736444)*x9);
x23=((1.0)*x0);
x24=((0.866025403784439)*x8);
x25=((1.0)*x9);
x26=((0.866025403784439)*x7);
x27=((1.0)*x7);
x28=((0.32132208)*x7);
x29=((0.0667221997732329)*x5);
x30=((0.433012701892219)*x5);
x31=(x0*x1);
x32=(x3*x4);
x33=(x0*x6);
x34=(x6*x7);
x35=(x2*x3);
x36=(x1*x2);
x37=(x1*x4);
x38=((-0.866025403784439)*x7);
x39=((-0.433012701892219)*x7);
x40=(x5*x7);
x41=((-0.5)*x6);
x42=((-1.0)*x6);
x43=(x0*x5);
x44=((0.75)*x34);
x45=((0.866025403784439)*x37);
x46=((0.433012701892219)*x37);
x47=((0.433012701892219)*x35);
x48=((0.433012701892219)*x2*x31);
x49=((0.433012701892219)*x0*x32);
x50=((0.866025403784439)*x0*x32);
x51=((0.866025403784439)*x2*x31);
x52=(x20*x36);
x53=(x20*x32);
x54=((((-0.5)*x32))+(((-0.5)*x36)));
x55=((((0.5)*x36))+(((0.5)*x32)));
x56=((((1.0)*x32))+(((1.0)*x36)));
x57=((((-0.866025403784439)*x36))+(((-0.866025403784439)*x32)));
x58=((((-0.433012701892219)*x36))+(((-0.433012701892219)*x32)));
x59=(((x31*x4))+(((-1.0)*x23*x35)));
x60=((((-1.0)*x27*x37))+((x35*x7)));
x61=(x5*x54);
x62=(x5*x58);
x63=(x55*x8);
x64=(x56*x6);
x65=(x5*x57);
x66=((((0.5)*x31*x4))+(((-0.5)*x0*x35)));
x67=(x17*(((((-1.0)*x37))+x35)));
x68=((0.866025403784439)*x65);
x69=(x19*x54);
x70=((-1.0)*x56*x6*x9);
x71=(x53+x52);
x72=(x59*x6);
x73=(x5*x59);
x74=(x6*x60);
x75=(x5*x66);
x76=(x5*x67);
x77=(x14*x60);
x78=(x19*x66);
x79=(x19*x67);
x80=(x45+x61);
x81=(x47+x68);
x82=(x46+x69);
x83=(x48+x49+x44);
x84=(x9*((x72+x40)));
x85=(x9*((x74+x43)));
x86=((((-0.5)*x43))+((x41*x60)));
x87=(x80+(((-0.866025403784439)*x35)));
x88=(x8*x86);
x89=(x87*x9);
x90=(x75+x51+x50);
x91=(x78+x48+x49);
x92=((((-1.0)*x17*x6))+x90);
x93=((((-0.5)*x33))+x76+((x26*(((((-1.0)*x36))+(((-1.0)*x32)))))));
eerot[0]=(((x10*((((x14*x59))+((x9*(((((-1.0)*x12*x6))+x91))))+(((-1.0)*x83))+((x8*(((((-0.5)*x72))+(((-1.0)*x17*x5))))))))))+((x11*((((x8*(((((-0.5)*x34))+x90))))+x84)))));
eerot[1]=((((-1.0)*x21*x92))+(((-1.0)*x24*(((((-1.0)*x27*x5))+(((-1.0)*x13*x59))))))+(((-0.25)*x2*x31))+(((-1.0)*x20*x6))+((x30*x59))+(((-0.25)*x0*x32)));
eerot[2]=(((x10*((x84+((x8*x92))))))+((x11*(((((-0.75)*x73))+(((-1.0)*x8*(((((-0.5)*x40))+((x41*x59))))))+(((-1.0)*x9*(((((-0.25)*x34))+x91))))+x83)))));
IkReal x94=(x0*x35);
IkReal x95=(x31*x4);
eetrans[0]=((((-0.32132208)*x0*x32))+(((0.125)*x94))+(((-0.32132208)*x2*x31))+(((-1.0)*x15*(((((-1.0)*x40))+((x42*x59))))))+(((-0.135)*x0))+(((-1.0)*x22*x92))+(((-0.125)*x95))+(((-0.123422199773233)*x34))+((x5*(((((0.0567)*x95))+(((-0.0567)*x94))))))+(((-0.6)*x31))+((x29*x59)));
eerot[3]=(((x11*((x85+((x8*x93))))))+((x10*((((x9*(((((-0.25)*x33))+((x36*x39))+x79+((x32*x39))))))+x77+x71+x88+(((-0.75)*x33)))))));
eerot[4]=((((-1.0)*x21*x93))+(((-1.0)*x24*(((((-1.0)*x13*x60))+(((-1.0)*x23*x5))))))+(((-0.433012701892219)*x33))+((x12*x32))+((x12*x36))+((x30*x60)));
IkReal x96=((1.0)*x71);
eerot[5]=(((x11*(((((0.75)*x33))+(((-1.0)*x25*(((((-0.25)*x33))+x79+(((-1.0)*x96))))))+(((-1.0)*x88))+(((-1.0)*x77))+(((-1.0)*x96))))))+((x10*((((x8*(((((-0.5)*x33))+((x36*x38))+x76+((x32*x38))))))+x85)))));
eetrans[1]=(((x29*x60))+(((-1.0)*x18*x35))+((x18*x37))+((x28*x32))+((x28*x36))+(((-1.0)*x15*(((((-1.0)*x43))+((x42*x60))))))+(((0.6)*x1*x7))+(((0.135)*x7))+(((-1.0)*x22*x93))+(((-0.123422199773233)*x33))+((x5*((((x16*x35))+(((-1.0)*x16*x37)))))));
eerot[6]=(((x10*((((x6*x63))+(((-0.433012701892219)*x37))+x81+((x9*(((((-0.433012701892219)*x35))+x82))))))))+((x11*((x70+((x8*x87)))))));
eerot[7]=((((-1.0)*x21*x87))+(((-0.25)*x37))+(((0.25)*x35))+x62+(((-1.0)*x24*x64)));
eerot[8]=(((x11*((x46+(((-1.0)*x81))+(((-1.0)*x25*(((((-1.0)*x47))+x82))))+(((-1.0)*x13*x63))))))+((x10*((((x8*((x80+(((-0.866025403784439)*x35))))))+x70)))));
eetrans[2]=((0.45)+(((0.32132208)*x35))+(((-0.32132208)*x37))+(((0.102300001246463)*x62))+(((0.0258941593767686)*x65))+(((0.6)*x3))+(((0.125)*x36))+(((0.125)*x32))+(((-1.0)*x22*x87))+((x5*(((((-0.0567)*x36))+(((-0.0567)*x32))))))+(((-1.0)*x15*x64)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API const int* GetFreeIndices() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=((-1.0)*r02);
new_r02=r01;
new_px=((((-0.102300001246463)*r01))+px);
new_r10=r10;
new_r11=((-1.0)*r12);
new_r12=r11;
new_py=((((-0.102300001246463)*r11))+py);
new_r20=r20;
new_r21=((-1.0)*r22);
new_r22=r21;
new_pz=((-0.45)+(((-0.102300001246463)*r21))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x97=((1.0)*px);
IkReal x98=((1.0)*pz);
IkReal x99=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x99))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x98)));
rxp0_2=((((-1.0)*r10*x97))+((py*r00)));
rxp1_0=((((-1.0)*r21*x99))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x98)));
rxp1_2=((((-1.0)*r11*x97))+((py*r01)));
rxp2_0=((((-1.0)*r22*x99))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x98)));
rxp2_2=((((-1.0)*r12*x97))+((py*r02)));
IkReal op[162], zeror[48];
int numroots;;
IkReal x100=((0.0865999997732329)*r20);
IkReal x101=(rxp2_2+(((-1.0)*x100)));
IkReal x102=((0.0865999997732329)*r10);
IkReal x103=((1.0)*rxp2_1);
IkReal x104=((2.0)*rxp2_0);
IkReal x105=((0.173199999546466)*r00);
IkReal x106=((0.173199999546466)*r11);
IkReal x107=((0.0865999997732329)*r01);
IkReal x108=((2.0)*py);
IkReal x109=((1.0)*px);
IkReal x110=((0.0233819999387729)*r11);
IkReal x111=((0.5656)*npz);
IkReal x112=((0.27)*py);
IkReal x113=((0.03375)*r22);
IkReal x114=((0.25)*rxp2_0);
IkReal x115=((0.173199999546466)*npy);
IkReal x116=((0.076356)*r12);
IkReal x117=((1.0)*pp);
IkReal x118=((0.0216499999433082)*r00);
IkReal x119=((0.076356)*r02);
IkReal x120=((0.25)*rxp2_1);
IkReal x121=((0.0233819999387729)*r01);
IkReal x122=((0.27)*px);
IkReal x123=((0.0216499999433082)*r10);
IkReal x124=((0.0432999998866164)*r01);
IkReal x125=((0.346399999092932)*npx);
IkReal x126=((0.0467639998775458)*r10);
IkReal x127=((0.149995599542693)*r22);
IkReal x128=((0.0567)*r21);
IkReal x129=((1.73205080756888)*rxp0_2);
IkReal x130=((0.149995599542693)*r12);
IkReal x131=((3.46410161513775)*rxp1_1);
IkReal x132=((0.1134)*r10);
IkReal x133=((0.0567)*r11);
IkReal x134=((1.73205080756888)*rxp0_1);
IkReal x135=((0.299991199085385)*r02);
IkReal x136=((3.46410161513775)*rxp0_0);
IkReal x137=((0.1134)*r01);
IkReal x138=((1.73205080756888)*r00);
IkReal x139=((0.0567)*r00);
IkReal x140=((0.0374988998856732)*r02);
IkReal x141=((0.433012701892219)*rxp0_0);
IkReal x142=((0.866247936760957)*npx);
IkReal x143=((0.014175)*r01);
IkReal x144=((0.0584567147554496)*r20);
IkReal x145=((0.116943471462729)*r10);
IkReal x146=((0.116943471462729)*r00);
IkReal x147=((0.0374988998856732)*r12);
IkReal x148=((0.433012701892219)*rxp0_1);
IkReal x149=((0.014175)*r11);
IkReal x150=((0.866025403784439)*rxp1_1);
IkReal x151=((0.02835)*r10);
IkReal x152=((0.02835)*r00);
IkReal x153=((0.116913429510899)*r21);
IkReal x154=((1.73249587352191)*npy);
IkReal x155=((0.866025403784439)*rxp1_0);
IkReal x156=((0.015309)*r00);
IkReal x157=((0.147561471462729)*r10);
IkReal x158=((0.0716499998866164)*r20);
IkReal x159=((0.866025403784439)*rxp1_2);
IkReal x160=((0.5)*rxp2_2);
IkReal x161=((0.5)*rxp2_1);
IkReal x162=((0.0716499998866164)*r10);
IkReal x163=((0.143299999773233)*r00);
IkReal x164=((1.0)*rxp2_0);
IkReal x165=((1.73205080756888)*rxp1_0);
IkReal x166=((0.866025403784439)*r01);
IkReal x167=((0.5)*r02);
IkReal x168=((1.73205080756888)*r11);
IkReal x169=((0.0582499997732329)*r01);
IkReal x170=((0.0491036403945777)*r02);
IkReal x171=((0.116499999546466)*r11);
IkReal x172=((0.0982072807891553)*r12);
IkReal x173=((0.024920017093464)*r12);
IkReal x174=((0.0179124999716541)*r00);
IkReal x175=((0.0818537356701375)*r11);
IkReal x176=((0.125)*rxp2_0);
IkReal x177=((0.0292283573777248)*r21);
IkReal x178=((0.21650635094611)*rxp1_0);
IkReal x179=((0.016875)*r22);
IkReal x180=((0.184592719210845)*npz);
IkReal x181=((0.606323967926944)*npy);
IkReal x182=((0.0179124999716541)*r10);
IkReal x183=((0.0818537356701375)*r01);
IkReal x184=((0.125)*rxp2_1);
IkReal x185=((0.21650635094611)*rxp1_1);
IkReal x186=((0.024920017093464)*r02);
IkReal x187=((0.0358249999433082)*r11);
IkReal x188=((1.21264793585389)*npx);
IkReal x189=((0.0358249999433082)*r01);
IkReal x190=((0.132252471462729)*r00);
IkReal x191=((0.013257982906536)*r02);
IkReal x192=((0.0157274999387729)*r01);
IkReal x193=((0.0503987357925917)*r11);
IkReal x194=((0.051435982906536)*r12);
IkReal x195=((0.038178)*r02);
IkReal x196=((0.0661262357313646)*r01);
IkReal x197=(rxp2_2+x100);
IkReal x198=((-0.173199999546466)*r21);
IkReal x199=((-1.0)*r02);
IkReal x200=((-2.0)*r12);
IkReal x201=((((-0.0432999998866164)*r11))+(((0.0467639998775458)*r00)));
IkReal x202=((((3.46410161513775)*rxp1_2))+(((-0.1134)*r20)));
IkReal x203=((-1.73205080756888)*r00);
IkReal x204=((-0.0567)*r00);
IkReal x205=((-3.46410161513775)*r10);
IkReal x206=((0.225724193482918)+x174);
IkReal x207=((0.225724193482918)+x178);
IkReal x208=(x134+x133);
IkReal x209=(x129+(((0.143299999773233)*r21)));
IkReal x210=(x162+x161);
IkReal x211=((((0.143299999773233)*r11))+x134);
IkReal x212=(x161+x150);
IkReal x213=(x166+x167);
IkReal x214=(x170+x169);
IkReal x215=(x144+x188);
IkReal x216=(x141+x189);
IkReal x217=(x120+x119);
IkReal x218=(x123+x121);
IkReal x219=(x128+x129);
IkReal x220=(x185+x183);
IkReal x221=(x154+x153);
IkReal x222=(x148+x149);
IkReal x223=(x126+x124);
IkReal x224=(x192+x185);
IkReal x225=(x148+x187);
IkReal x226=(x137+x136);
IkReal x227=(x142+x144);
IkReal x228=(x112+x114);
IkReal x229=(x122+x184);
IkReal x230=(x141+x143);
IkReal x231=(x127+(((-1.0)*x219)));
IkReal x232=((((-1.0)*x158))+(((-1.0)*x160))+x159);
IkReal x233=((((-1.0)*x159))+(((-1.0)*x160))+x158);
IkReal x234=((0.238674600039276)+x113+x111);
IkReal x235=(x122+x218);
IkReal x236=(x127+x219);
IkReal x237=(x130+x208);
IkReal x238=(x177+x176+x181);
IkReal x239=(x179+x117+x180);
IkReal x240=(x140+x230);
IkReal x241=(x177+x112+x181);
IkReal x242=(x110+x117+x116);
IkReal x243=(x182+x229);
IkReal x244=(x115+x228);
IkReal x245=(x117+x116+x118);
op[0]=x197;
op[1]=x197;
op[2]=0;
op[3]=x198;
op[4]=x198;
op[5]=0;
op[6]=x101;
op[7]=x101;
op[8]=0;
op[9]=((((-1.0)*x103))+(((-1.0)*x102)));
op[10]=(x104+x105);
op[11]=(rxp2_1+x102);
op[12]=x106;
op[13]=((-0.346399999092932)*r01);
op[14]=((-0.173199999546466)*r11);
op[15]=((((-1.0)*x103))+x102);
op[16]=((((-1.0)*x105))+x104);
op[17]=(rxp2_1+(((-1.0)*x102)));
op[18]=x199;
op[19]=x200;
op[20]=r02;
op[21]=0;
op[22]=0;
op[23]=0;
op[24]=x199;
op[25]=x200;
op[26]=r02;
op[27]=((((-1.0)*x107))+px);
op[28]=((((-1.0)*x106))+x108);
op[29]=((((-1.0)*x109))+x107);
op[30]=((-0.173199999546466)*r00);
op[31]=((-0.346399999092932)*r10);
op[32]=x105;
op[33]=(x107+px);
op[34]=(x108+x106);
op[35]=((((-1.0)*x109))+(((-1.0)*x107)));
op[36]=(x118+x234+x244+(((-1.0)*x242)));
op[37]=((((-1.0)*x122))+x217+x218);
op[38]=0;
op[39]=(x125+(((-1.0)*x223)));
op[40]=x201;
op[41]=0;
op[42]=((((-1.0)*x115))+x110+x228+x234+(((-1.0)*x245)));
op[43]=((((-1.0)*x235))+x217);
op[44]=0;
op[45]=((((-1.0)*x122))+x120+x218);
op[46]=(x110+x115+x234+(((-1.0)*x245))+(((-1.0)*x228)));
op[47]=x119;
op[48]=x201;
op[49]=(x125+x223);
op[50]=0;
op[51]=(x120+(((-1.0)*x235)));
op[52]=(x118+x234+(((-1.0)*x242))+(((-1.0)*x244)));
op[53]=x119;
op[54]=x231;
op[55]=x231;
op[56]=0;
op[57]=x202;
op[58]=x202;
op[59]=0;
op[60]=x236;
op[61]=x236;
op[62]=0;
op[63]=((((-1.0)*x130))+x208);
op[64]=(x135+(((-1.0)*x226)));
op[65]=(x130+(((-1.0)*x208)));
op[66]=(x132+(((-1.0)*x131)));
op[67]=((((-0.2268)*r00))+(((6.92820323027551)*rxp1_0)));
op[68]=(x131+(((-1.0)*x132)));
op[69]=((-1.0)*x237);
op[70]=(x135+x226);
op[71]=x237;
op[72]=x138;
op[73]=((3.46410161513775)*r10);
op[74]=x203;
op[75]=((-3.46410161513775)*r01);
op[76]=((-6.92820323027551)*r11);
op[77]=((3.46410161513775)*r01);
op[78]=x203;
op[79]=x205;
op[80]=x138;
op[81]=x204;
op[82]=((-0.1134)*r10);
op[83]=x139;
op[84]=x137;
op[85]=((0.2268)*r11);
op[86]=((-0.1134)*r01);
op[87]=x139;
op[88]=x132;
op[89]=x204;
op[90]=(x140+x145+(((-1.0)*x230))+(((-1.0)*x227)));
op[91]=((((-1.0)*x146))+x147+(((-1.0)*x222)));
op[92]=0;
op[93]=((((-1.0)*x152))+x155+x221+(((-0.233886942925458)*r11)));
op[94]=((((-1.0)*x151))+(((0.233886942925458)*r01))+x150);
op[95]=0;
op[96]=((((-1.0)*x145))+x227+x240);
op[97]=(x146+x147+x222);
op[98]=0;
op[99]=(x156+x147+(((-1.0)*x222)));
op[100]=((((-1.0)*x140))+x157+x230+(((-1.0)*x227)));
op[101]=((-0.132252471462729)*r00);
op[102]=((((-1.0)*x151))+(((-0.030618)*r01))+x150);
op[103]=((((-1.0)*x155))+x152+x221+(((-0.295122942925458)*r11)));
op[104]=((0.264504942925458)*r01);
op[105]=((((-1.0)*x156))+x147+x222);
op[106]=((((-1.0)*x157))+x227+(((-1.0)*x240)));
op[107]=x190;
op[108]=x232;
op[109]=x232;
op[110]=0;
op[111]=x209;
op[112]=x209;
op[113]=0;
op[114]=x233;
op[115]=x233;
op[116]=0;
op[117]=((((-1.0)*x150))+x210);
op[118]=((((-1.0)*x164))+(((-1.0)*x163))+x165);
op[119]=(x150+(((-1.0)*x210)));
op[120]=((-1.0)*x211);
op[121]=((((0.286599999546466)*r01))+x136);
op[122]=x211;
op[123]=((((-1.0)*x162))+x212);
op[124]=((((-1.0)*x165))+(((-1.0)*x164))+x163);
op[125]=(x162+(((-1.0)*x212)));
op[126]=((((-1.0)*x166))+x167);
op[127]=((((-1.0)*x168))+r12);
op[128]=((((-1.0)*x167))+x166);
op[129]=x203;
op[130]=x205;
op[131]=x138;
op[132]=x213;
op[133]=(x168+r12);
op[134]=((-1.0)*x213);
op[135]=(px+(((-1.0)*x214)));
op[136]=((((-1.0)*x171))+(((-1.0)*x172))+x108);
op[137]=((((-1.0)*x109))+x214);
op[138]=((-0.116499999546466)*r00);
op[139]=((-0.232999999092932)*r10);
op[140]=((0.116499999546466)*r00);
op[141]=((((-1.0)*x170))+x169+px);
op[142]=((((-1.0)*x172))+x171+x108);
op[143]=((((-1.0)*x169))+(((-1.0)*x109))+x170);
op[144]=((((-1.0)*x176))+(((-1.0)*x174))+(((-1.0)*x175))+x173+(((-1.0)*x239))+x207+x241);
op[145]=((((-1.0)*x186))+x220+(((-1.0)*x243)));
op[146]=0;
op[147]=((((-0.163707471340275)*r10))+x215+x216);
op[148]=(x225+(((0.163707471340275)*r00)));
op[149]=0;
op[150]=((((-1.0)*x178))+x173+x175+x112+(((-1.0)*x239))+(((-1.0)*x238))+x206);
op[151]=((((-1.0)*x186))+x182+(((-1.0)*x229))+(((-1.0)*x220)));
op[152]=0;
op[153]=(x191+x224+(((-1.0)*x243)));
op[154]=((((-1.0)*x178))+(((-1.0)*x193))+(((-1.0)*x112))+x194+(((-1.0)*x239))+x238+x206);
op[155]=((((-1.0)*x195))+x196);
op[156]=((((0.0314549998775458)*r00))+x225);
op[157]=(x215+(((-1.0)*x216))+(((-0.100797471585183)*r10)));
op[158]=x190;
op[159]=(x191+x182+(((-1.0)*x229))+(((-1.0)*x224)));
op[160]=((((-1.0)*x174))+x176+x193+x194+(((-1.0)*x239))+x207+(((-1.0)*x241)));
op[161]=((((-1.0)*x195))+(((-1.0)*x196)));
solvedialyticpoly12qep(op,zeror,numroots);
IkReal j4array[16], cj4array[16], sj4array[16], j5array[16], cj5array[16], sj5array[16], j0array[16], cj0array[16], sj0array[16];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ij4 += 3)
{
IkReal htj4 = zeror[ij4+0], htj5 = zeror[ij4+1], htj0 = zeror[ij4+2];
if(isnan(htj4)||isnan(htj5)||isnan(htj0)){
continue;
}
j4array[numsolutions]=((2.0)*(atan(htj4)));
j5array[numsolutions]=((2.0)*(atan(htj5)));
j0array[numsolutions]=((2.0)*(atan(htj0)));
if(isinf(htj4)){
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
}
else{
IkReal x246=htj4*htj4;
CheckValue<IkReal> x247=IKPowWithIntegerCheck(((1.0)+x246),-1);
if(!x247.valid){
continue;
}
cj4array[numsolutions]=((x247.value)*(((1.0)+(((-1.0)*x246)))));
CheckValue<IkReal> x248=IKPowWithIntegerCheck(((1.0)+(htj4*htj4)),-1);
if(!x248.valid){
continue;
}
sj4array[numsolutions]=((2.0)*htj4*(x248.value));
}
if(isinf(htj5)){
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
}
else{
IkReal x249=htj5*htj5;
CheckValue<IkReal> x250=IKPowWithIntegerCheck(((1.0)+x249),-1);
if(!x250.valid){
continue;
}
cj5array[numsolutions]=((x250.value)*(((1.0)+(((-1.0)*x249)))));
CheckValue<IkReal> x251=IKPowWithIntegerCheck(((1.0)+(htj5*htj5)),-1);
if(!x251.valid){
continue;
}
sj5array[numsolutions]=((2.0)*htj5*(x251.value));
}
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x252=htj0*htj0;
CheckValue<IkReal> x253=IKPowWithIntegerCheck(((1.0)+x252),-1);
if(!x253.valid){
continue;
}
cj0array[numsolutions]=((x253.value)*(((1.0)+(((-1.0)*x252)))));
CheckValue<IkReal> x254=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x254.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x254.value));
}
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j4valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj4 = 16;
_nj5 = 1;
_nj0 = 1;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
_ij5[0] = 0; _ij5[1] = -1;
_ij0[0] = 0; _ij0[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( !j4valid[iij4] ) { continue; }
if( IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj5array[ij4]-cj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij4]-sj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj0array[ij4]-cj0array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij4]-sj0array[iij4]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j4valid[iij4]=false; _ij4[1] = iij4; _ij5[1] = 0; _ij0[1] = 0;  break; 
}
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

    j5 = j5array[ij4]; cj5 = cj5array[ij4]; sj5 = sj5array[ij4];

    j0 = j0array[ij4]; cj0 = cj0array[ij4]; sj0 = sj0array[ij4];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+3, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+5, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+4, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+7, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}

static inline bool checkconsistency12(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 11; ++i) {
        norm += IKabs(Breal[i]);
    }
    IkReal tol = 1e-6*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[0]-Breal[1]) < tol && IKabs(Breal[0]*Breal[2]-Breal[3]) < tol && IKabs(Breal[1]*Breal[2]-Breal[4]) < tol && IKabs(Breal[2]*Breal[2]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol && IKabs(Breal[1]*Breal[5]-Breal[7]) < tol && IKabs(Breal[2]*Breal[5]-Breal[8]) < tol && IKabs(Breal[0]*Breal[8]-Breal[9]) < tol && IKabs(Breal[1]*Breal[8]-Breal[10]) < tol;
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3eval[2];
IkReal x255=((2.0)*sj4);
IkReal x256=(r11*sj5);
IkReal x257=(cj5*r10);
IkReal x258=((0.866025403784439)*sj4);
IkReal x259=(cj4*r12);
IkReal x260=(r10*sj5);
IkReal x261=(cj5*r11);
IkReal x262=((1.0)*cj4);
IkReal x263=((0.433012701892219)*x261);
j3eval[0]=((((-1.0)*x255*x257))+(((1.73205080756888)*x259))+x261+x260+(((-1.0)*x261*x262))+(((0.577350269189626)*r12))+((x255*x256))+(((-1.0)*x260*x262)));
j3eval[1]=IKsign(((((-1.0)*cj4*x263))+(((0.25)*r12))+(((-1.0)*x257*x258))+(((0.433012701892219)*x260))+((x256*x258))+x263+(((0.75)*x259))+(((-0.433012701892219)*cj4*x260))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x264=((0.433012701892219)*cj4);
IkReal x265=(r00*sj5);
IkReal x266=(cj5*r01);
IkReal x267=(cj4*r02);
IkReal x268=((1.73205080756888)*cj4);
IkReal x269=(cj5*r00*sj4);
IkReal x270=(r01*sj4*sj5);
j3eval[0]=((((-1.73205080756888)*x266))+(((-1.73205080756888)*x265))+((x266*x268))+(((3.46410161513775)*x269))+(((-3.46410161513775)*x270))+(((-1.0)*r02))+(((-3.0)*x267))+((x265*x268)));
j3eval[1]=IKsign(((((0.866025403784439)*x269))+(((-0.25)*r02))+((x264*x266))+((x264*x265))+(((-0.866025403784439)*x270))+(((-0.433012701892219)*x265))+(((-0.433012701892219)*x266))+(((-0.75)*x267))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x271=(r20*sj5);
IkReal x272=((1.73205080756888)*cj4);
IkReal x273=(cj4*r22);
IkReal x274=(cj5*r21);
IkReal x275=((0.433012701892219)*cj4);
IkReal x276=(r21*sj4*sj5);
IkReal x277=(cj5*r20*sj4);
j3eval[0]=(((x272*x274))+((x271*x272))+(((-3.46410161513775)*x276))+(((3.46410161513775)*x277))+(((-1.0)*r22))+(((-3.0)*x273))+(((-1.73205080756888)*x271))+(((-1.73205080756888)*x274)));
j3eval[1]=IKsign((((x271*x275))+(((0.866025403784439)*x277))+((x274*x275))+(((-0.866025403784439)*x276))+(((-0.433012701892219)*x271))+(((-0.433012701892219)*x274))+(((-0.25)*r22))+(((-0.75)*x273))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x278=((0.5)*sj4);
IkReal x279=(sj0*sj5);
IkReal x280=(cj0*r10);
IkReal x281=(cj0*r11);
IkReal x282=((1.0)*cj4);
IkReal x283=((0.433012701892219)*cj4);
IkReal x284=(r02*sj0);
IkReal x285=((0.25)*cj4);
IkReal x286=((0.866025403784439)*sj4);
IkReal x287=(cj5*r01*sj0);
IkReal x288=((0.433012701892219)*cj0*r12);
IkReal x289=(cj5*r00*sj0);
CheckValue<IkReal> x290=IKPowWithIntegerCheck(IKsign((((r22*(((-0.25)+(((-0.75)*cj4))))))+((r21*(((((-1.0)*sj5*x286))+(((-0.433012701892219)*cj5))+((cj5*x283))))))+((r20*((((sj5*x283))+(((-0.433012701892219)*sj5))+((cj5*x286)))))))),-1);
if(!x290.valid){
continue;
}
CheckValue<IkReal> x291 = IKatan2WithCheck(IkReal((((x284*x286))+((cj5*x278*x281))+((sj5*x278*x280))+(((-1.0)*cj0*r12*x286))+((cj4*sj5*x281))+(((-1.0)*cj5*x280*x282))+(((-1.0)*r00*x278*x279))+(((-1.0)*r01*x279*x282))+((cj4*x289))+(((-1.0)*x278*x287)))),IkReal(((((-1.0)*sj5*x280*x285))+(((0.75)*x287))+((x285*x287))+((x278*x289))+((sj5*x278*x281))+(((-0.75)*cj5*x281))+(((-1.0)*cj5*x278*x280))+((r00*x279*x285))+(((-1.0)*r01*x278*x279))+(((-0.75)*sj5*x280))+(((0.75)*r00*x279))+(((-1.0)*cj5*x281*x285))+(((0.433012701892219)*x284))+(((-1.0)*x288))+((cj0*r12*x283))+(((-1.0)*x283*x284)))),IKFAST_ATAN2_MAGTHRESH);
if(!x291.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x290.value)))+(x291.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x292=IKsin(j3);
IkReal x293=IKcos(j3);
IkReal x294=((0.5)*sj4);
IkReal x295=((1.0)*cj4);
IkReal x296=((0.25)*cj4);
IkReal x297=((0.433012701892219)*x292);
IkReal x298=(cj5*x292);
IkReal x299=(sj5*x292);
IkReal x300=(sj5*x293);
IkReal x301=(cj5*x293);
IkReal x302=((0.866025403784439)*sj4*x293);
evalcond[0]=((((-1.0)*r22*x302))+((r21*x296*x298))+((r20*x294*x300))+(((-1.0)*r21*x294*x299))+((r20*x294*x298))+(((0.75)*r20*x299))+((cj4*r21*x300))+((r21*x294*x301))+((r20*x296*x299))+(((0.75)*r21*x298))+(((-1.0)*cj4*r22*x297))+(((-1.0)*r20*x295*x301))+((r22*x297)));
evalcond[1]=(((r01*x296*x298))+((r00*x294*x298))+(((-1.0)*r00*x295*x301))+((r01*x294*x301))+cj0+((r00*x296*x299))+(((-1.0)*r01*x294*x299))+(((-1.0)*r02*x302))+(((0.75)*r00*x299))+(((0.75)*r01*x298))+((cj4*r01*x300))+(((-1.0)*cj4*r02*x297))+((r02*x297))+((r00*x294*x300)));
evalcond[2]=(((r12*x297))+sj0+((r10*x294*x300))+(((-1.0)*r11*x294*x299))+(((0.75)*r10*x299))+((r10*x296*x299))+(((-1.0)*cj4*r12*x297))+((r11*x296*x298))+((r10*x294*x298))+((cj4*r11*x300))+(((-1.0)*r10*x295*x301))+(((-1.0)*r12*x302))+(((0.75)*r11*x298))+((r11*x294*x301)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[8+1], zeror[8];
int numroots;
IkReal x303=((0.25)*r12);
IkReal x304=((0.0245518201972888)*r22);
IkReal x305=(cj5*r21);
IkReal x306=((0.866025403784439)*sj4);
IkReal x307=(r20*sj5);
IkReal x308=((0.02835)*sj4);
IkReal x309=((0.014175)*cj4);
IkReal x310=((0.433012701892219)*cj5*r11);
IkReal x311=((0.75)*cj4*r12);
IkReal x312=((0.433012701892219)*r10*sj5);
IkReal x313=((0.0724249997732329)*x305);
IkReal x314=((0.0724249997732329)*x307);
IkReal x315=(cj4*x312);
IkReal x316=(cj5*r10*x306);
IkReal x317=(cj4*x310);
IkReal x318=(r11*sj5*x306);
IkReal x319=(x305*x309);
IkReal x320=(x307*x309);
IkReal x321=(cj5*r20*x308);
IkReal x322=((((1.0)*pz))+((r21*sj5*x308))+((cj4*x304)));
IkReal x323=(x315+x317+x316);
IkReal x324=(x303+x318+x311+x310+x312);
IkReal x325=(x304+x320+x321+x319+x314+x313);
IkReal x326=(cj0+(((-1.0)*x324))+x323);
IkReal x327=((((-1.0)*x324))+x323+(((-1.0)*cj0)));
IkReal x328=((0.725)+(((-1.0)*x322))+x325);
IkReal x329=((0.475)+(((-1.0)*x322))+x325);
IkReal x330=((-0.725)+(((-1.0)*x322))+x325);
IkReal x331=((-0.475)+(((-1.0)*x322))+x325);
IkReal gconst0=x326;
IkReal gconst1=x327;
IkReal gconst2=x328;
IkReal gconst3=x329;
IkReal gconst4=x326;
IkReal gconst5=x327;
IkReal gconst6=x328;
IkReal gconst7=x329;
IkReal gconst8=x327;
IkReal gconst9=x326;
IkReal gconst10=x330;
IkReal gconst11=x331;
IkReal gconst12=x327;
IkReal gconst13=x326;
IkReal gconst14=x330;
IkReal gconst15=x331;
IkReal x332=cj0*cj0;
IkReal x333=((0.5656)*gconst1);
IkReal x334=(gconst12*gconst7);
IkReal x335=(gconst10*gconst13);
IkReal x336=(gconst0*gconst11);
IkReal x337=(gconst12*gconst15);
IkReal x338=((0.31990336)*gconst9);
IkReal x339=(gconst14*gconst5);
IkReal x340=((0.5656)*gconst9);
IkReal x341=(cj0*gconst9);
IkReal x342=(gconst13*gconst14);
IkReal x343=((0.31990336)*gconst12);
IkReal x344=((0.06990336)*gconst4);
IkReal x345=((2.2624)*cj0);
IkReal x346=(gconst11*gconst12);
IkReal x347=(gconst1*gconst6);
IkReal x348=((0.5656)*gconst8);
IkReal x349=((1.0)*gconst3);
IkReal x350=(gconst5*gconst6);
IkReal x351=(gconst0*gconst3);
IkReal x352=(gconst11*gconst8);
IkReal x353=((1.0)*gconst2);
IkReal x354=(gconst0*gconst4);
IkReal x355=((0.5656)*gconst0);
IkReal x356=(gconst13*gconst6);
IkReal x357=(gconst4*gconst7);
IkReal x358=((2.0)*cj0);
IkReal x359=(gconst11*gconst4);
IkReal x360=(gconst2*gconst5);
IkReal x361=((0.5656)*gconst12);
IkReal x362=(gconst1*gconst14);
IkReal x363=(gconst12*gconst3);
IkReal x364=(gconst3*gconst4);
IkReal x365=((1.27961344)*cj0);
IkReal x366=(gconst1*gconst10);
IkReal x367=(gconst15*gconst4);
IkReal x368=(gconst1*gconst2);
IkReal x369=((16.0)*gconst6);
IkReal x370=((1.1312)*cj0);
IkReal x371=(gconst10*gconst5);
IkReal x372=((0.31990336)*gconst0);
IkReal x373=(gconst2*gconst9);
IkReal x374=((0.06990336)*gconst12);
IkReal x375=((0.31990336)*gconst4);
IkReal x376=(gconst10*gconst9);
IkReal x377=(gconst13*gconst2);
IkReal x378=(gconst12*gconst2);
IkReal x379=((1.0)*gconst9);
IkReal x380=((0.5656)*gconst5);
IkReal x381=(gconst10*gconst12);
IkReal x382=(gconst3*gconst8);
IkReal x383=((0.5656)*gconst4);
IkReal x384=((0.31990336)*gconst1);
IkReal x385=(gconst10*gconst4);
IkReal x386=(gconst2*gconst4);
IkReal x387=((0.5656)*gconst13);
IkReal x388=((0.31990336)*gconst8);
IkReal x389=(gconst12*x340);
IkReal x390=(gconst12*x365);
IkReal x391=(gconst12*x338);
IkReal x392=((1.27961344)*x341);
IkReal x393=(gconst12*x333);
IkReal x394=(gconst4*x340);
IkReal x395=(gconst4*x365);
IkReal x396=(gconst4*x338);
IkReal x397=(gconst1*x343);
IkReal x398=(gconst1*x365);
IkReal x399=(gconst4*x333);
IkReal x400=(gconst1*x375);
IkReal x401=(gconst7*x354);
IkReal x402=(gconst11*x332);
IkReal x403=((9.0496)*x332);
IkReal x404=(x345*x346);
IkReal x405=((2.2624)*gconst14*x341);
IkReal x406=(x345*x363);
IkReal x407=(x345*x362);
IkReal x408=(x345*x359);
IkReal x409=((2.2624)*gconst6*x341);
IkReal x410=(x345*x347);
IkReal x411=(x345*x364);
IkReal x412=((16.0)*gconst14*x332);
IkReal x413=(x397+x396);
IkReal x414=(x394+x393);
IkReal x415=(x405+x404);
IkReal x416=(x410+x411);
IkReal x417=(x407+x406+x409+x408);
op[0]=((((-1.0)*gconst14*x335*x379))+(((-1.0)*x391))+(((-1.0)*x337*x352))+((x342*x352))+((x337*x376)));
op[1]=(((x335*x340))+(((-1.0)*x337*x348))+(((-1.0)*x337*x340))+(((-1.0)*gconst11*gconst13*x348))+x389+((x340*x381))+(((-1.0)*x346*x348))+((x340*x342))+(((-1.0)*x415))+((x342*x348)));
op[2]=((((-1.0)*gconst9*x342*x353))+((x367*x376))+(((-1.0)*gconst13*x338))+((x336*x342))+(((-1.0)*x390))+(((-1.0)*x335*x362))+(((-1.0)*gconst8*x337*x349))+(((-1.0)*x334*x352))+(((-1.0)*gconst8*x343))+(((-1.0)*gconst13*x388))+(((-1.0)*x339*x376))+(((-16.0)*gconst14*x402))+((x346*x358))+((x352*x356))+x392+((gconst9*x374))+(((-1.0)*x352*x367))+(((-1.0)*x336*x337))+(((2.0)*gconst14*x341))+(((-1.0)*gconst6*x335*x379))+((x342*x382))+((x337*x366))+((x337*x373))+(((-1.0)*x413))+((x334*x376))+((x339*x352)));
op[3]=(((gconst12*x370))+(((-1.0)*x334*x348))+(((-1.0)*x334*x340))+(((-1.0)*gconst14*x403))+(((-1.0)*x333*x337))+(((-1.0)*x348*x359))+((x340*x371))+((x340*x378))+((x340*x377))+(((-1.0)*x336*x387))+(((-1.1312)*x341))+(((-1.0)*x340*x367))+((x342*x355))+((x333*x342))+x414+x415+(((-1.0)*x348*x363))+(((-1.0)*x348*x367))+((x340*x356))+(((9.0496)*x402))+((x333*x335))+((x340*x385))+(((-1.0)*x389))+(((-1.0)*x336*x361))+((x348*x356))+(((-1.0)*x337*x355))+(((-1.0)*gconst13*gconst3*x348))+((x333*x381))+(((-1.0)*x417))+((x339*x348))+((x339*x340))+(((-1.0)*gconst11*gconst5*x348)));
op[4]=(((x367*x373))+(((-1.0)*gconst1*x342*x353))+((x358*x362))+((x358*x363))+((x336*x339))+(((-1.0)*x395))+(((-1.0)*x392))+(((-1.0)*x391))+(((-1.0)*gconst5*x388))+(((-1.0)*x350*x376))+((x356*x382))+(((-1.0)*x339*x366))+(((-1.0)*gconst8*x349*x367))+(((-1.0)*gconst0*x337*x349))+(((-1.0)*gconst13*x384))+(((-1.0)*x335*x347))+(((-1.0)*x352*x357))+((x366*x367))+(((-1.0)*gconst5*x338))+(((5.11845376)*x332))+((x336*x356))+x390+x398+((x342*x351))+(((2.0)*gconst6*x341))+(((-1.0)*gconst0*x343))+(((-1.0)*x369*x402))+(((-1.0)*gconst8*x375))+((gconst1*x374))+((x358*x359))+((x350*x352))+(((-1.0)*gconst9*x339*x353))+((x337*x368))+(((-1.0)*gconst3*x412))+((x339*x382))+((x334*x366))+(((-1.0)*x334*x336))+((gconst9*x344))+(((-1.0)*gconst8*x334*x349))+(((-1.0)*gconst9*x353*x356))+((x357*x376))+(((-1.0)*x336*x367))+((x334*x373))+(((-1.0)*x400))+(((-1.0)*gconst13*x372)));
op[5]=(((gconst3*x403))+((gconst4*x370))+(((-0.5656)*gconst15*x354))+(((-1.0)*gconst3*gconst5*x348))+(((-1.0)*gconst1*x370))+((x340*x360))+(((-1.0)*x333*x334))+(((-1.0)*x348*x357))+((x355*x356))+(((-1.0)*x336*x380))+(((-1.0)*x336*x383))+((x333*x378))+((x333*x377))+((x333*x371))+x399+x417+(((-1.0)*x348*x364))+((x340*x350))+((x333*x339))+(((-1.0)*x351*x387))+((x340*x386))+(((-1.0)*x333*x367))+(((-1.0)*x340*x357))+((x348*x350))+((x333*x356))+((x333*x385))+(((-1.0)*x414))+(((-1.0)*x416))+(((-1.0)*x334*x355))+((x339*x355))+(((-1.0)*x351*x361))+(((-1.0)*gconst6*x403)));
op[6]=((((-1.0)*gconst15*x349*x354))+((x358*x364))+(((-1.0)*gconst8*x349*x357))+(((-1.0)*x398))+(((-1.0)*gconst5*x384))+(((-1.0)*gconst13*x347*x353))+(((-1.0)*x347*x371))+(((-1.0)*gconst1*x339*x353))+((x350*x382))+((x336*x350))+((x351*x356))+x395+((x347*x358))+(((-1.0)*x336*x357))+(((-1.0)*gconst0*x334*x349))+((x357*x366))+((gconst1*x344))+(((-1.0)*gconst3*x332*x369))+((x334*x368))+(((-1.0)*x413))+(((-0.31990336)*x354))+((x357*x373))+(((-1.0)*gconst5*x372))+((x339*x351))+(((-1.0)*gconst9*x350*x353))+((x367*x368)));
op[7]=((((-1.0)*x333*x357))+(((-1.0)*x399))+(((-0.5656)*x401))+((x333*x360))+x416+(((-1.0)*x351*x380))+(((-1.0)*x351*x383))+((x350*x355))+((x333*x350))+((x333*x386)));
op[8]=(((x350*x351))+(((-1.0)*x349*x401))+(((-1.0)*gconst5*x347*x353))+((x357*x368))+(((-1.0)*x400)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x418=(sj1*sj5);
IkReal x419=((0.866025403784439)*sj4);
IkReal x420=(cj1*r22);
IkReal x421=(r22*sj1);
IkReal x422=((0.75)*cj4);
IkReal x423=((8.0)*pz);
IkReal x424=(cj4*r20);
IkReal x425=(cj1*r20);
IkReal x426=((0.433012701892219)*sj5);
IkReal x427=((1.50038543842169)*cj4);
IkReal x428=(cj5*sj1);
IkReal x429=((0.433012701892219)*r21);
IkReal x430=((1.73249587352191)*sj4);
IkReal x431=((0.866247936760957)*cj1);
IkReal x432=(cj4*r21);
IkReal x433=(cj1*cj5);
IkReal x434=((1.55904793494682)*r21);
IkReal x435=(cj1*r21*sj5);
if( IKabs((((x429*x433))+((x420*x422))+(((-1.0)*x421*x427))+((x425*x426))+(((-1.55904793494682)*r20*x418))+(((0.866247936760957)*x418*x424))+(((0.866247936760957)*x428*x432))+((r20*x428*x430))+(((-1.0)*cj1*x424*x426))+((x419*x435))+(((-4.8)*cj1*sj1))+(((0.25)*x420))+(((-1.0)*r21*x418*x430))+(((-1.0)*cj5*x419*x425))+(((-1.0)*x428*x434))+((sj1*x423))+(((-1.0)*cj4*x429*x433))+(((-0.762014561578311)*x421)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x430*x435))+(((-4.8)*(cj1*cj1)))+(((-1.0)*x421*x422))+(((-1.0)*x433*x434))+(((-1.0)*x420*x427))+((cj5*x431*x432))+((sj5*x424*x431))+(((-0.433012701892219)*r20*x418))+(((-1.55904793494682)*sj5*x425))+(((-1.0)*x428*x429))+(((-0.25)*x421))+((cj4*x428*x429))+(((0.433012701892219)*x418*x424))+((cj5*x425*x430))+(((-1.0)*r21*x418*x419))+(((-0.762014561578311)*x420))+((r20*x419*x428))+((cj1*x423)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x429*x433))+((x420*x422))+(((-1.0)*x421*x427))+((x425*x426))+(((-1.55904793494682)*r20*x418))+(((0.866247936760957)*x418*x424))+(((0.866247936760957)*x428*x432))+((r20*x428*x430))+(((-1.0)*cj1*x424*x426))+((x419*x435))+(((-4.8)*cj1*sj1))+(((0.25)*x420))+(((-1.0)*r21*x418*x430))+(((-1.0)*cj5*x419*x425))+(((-1.0)*x428*x434))+((sj1*x423))+(((-1.0)*cj4*x429*x433))+(((-0.762014561578311)*x421))))+IKsqr(((((-1.0)*x430*x435))+(((-4.8)*(cj1*cj1)))+(((-1.0)*x421*x422))+(((-1.0)*x433*x434))+(((-1.0)*x420*x427))+((cj5*x431*x432))+((sj5*x424*x431))+(((-0.433012701892219)*r20*x418))+(((-1.55904793494682)*sj5*x425))+(((-1.0)*x428*x429))+(((-0.25)*x421))+((cj4*x428*x429))+(((0.433012701892219)*x418*x424))+((cj5*x425*x430))+(((-1.0)*r21*x418*x419))+(((-0.762014561578311)*x420))+((r20*x419*x428))+((cj1*x423))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x429*x433))+((x420*x422))+(((-1.0)*x421*x427))+((x425*x426))+(((-1.55904793494682)*r20*x418))+(((0.866247936760957)*x418*x424))+(((0.866247936760957)*x428*x432))+((r20*x428*x430))+(((-1.0)*cj1*x424*x426))+((x419*x435))+(((-4.8)*cj1*sj1))+(((0.25)*x420))+(((-1.0)*r21*x418*x430))+(((-1.0)*cj5*x419*x425))+(((-1.0)*x428*x434))+((sj1*x423))+(((-1.0)*cj4*x429*x433))+(((-0.762014561578311)*x421))), ((((-1.0)*x430*x435))+(((-4.8)*(cj1*cj1)))+(((-1.0)*x421*x422))+(((-1.0)*x433*x434))+(((-1.0)*x420*x427))+((cj5*x431*x432))+((sj5*x424*x431))+(((-0.433012701892219)*r20*x418))+(((-1.55904793494682)*sj5*x425))+(((-1.0)*x428*x429))+(((-0.25)*x421))+((cj4*x428*x429))+(((0.433012701892219)*x418*x424))+((cj5*x425*x430))+(((-1.0)*r21*x418*x419))+(((-0.762014561578311)*x420))+((r20*x419*x428))+((cj1*x423))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x436=IKcos(j2);
IkReal x437=IKsin(j2);
IkReal x438=(cj3*r20);
IkReal x439=((0.014175)*cj4);
IkReal x440=(cj5*r11);
IkReal x441=(r00*sj5);
IkReal x442=(r10*sj5);
IkReal x443=(r21*sj3);
IkReal x444=((0.866025403784439)*sj4);
IkReal x445=(cj5*r20);
IkReal x446=(cj4*sj3);
IkReal x447=((1.0)*cj5);
IkReal x448=(r11*sj5);
IkReal x449=((0.02835)*sj4);
IkReal x450=(cj0*sj1);
IkReal x451=(r20*sj5);
IkReal x452=((0.25)*cj4);
IkReal x453=(r01*sj5);
IkReal x454=((0.433012701892219)*cj3);
IkReal x455=((0.0245518201972888)*r02);
IkReal x456=((1.0)*sj0);
IkReal x457=((0.433012701892219)*cj4);
IkReal x458=((0.75)*cj4);
IkReal x459=(cj5*r00);
IkReal x460=(cj5*r01);
IkReal x461=(r21*sj5);
IkReal x462=((0.0245518201972888)*r22);
IkReal x463=(cj5*r10);
IkReal x464=((0.75)*cj3);
IkReal x465=((0.2828)*sj0);
IkReal x466=(cj5*r21);
IkReal x467=(cj4*r12);
IkReal x468=((0.125)*sj0);
IkReal x469=((0.5)*cj5*sj4);
IkReal x470=(cj1*x437);
IkReal x471=((0.5)*sj3*sj4);
IkReal x472=(sj1*x436);
IkReal x473=((0.433012701892219)*x460);
IkReal x474=(sj1*x437);
IkReal x475=(cj1*x436);
IkReal x476=((0.5)*cj3*sj4);
IkReal x477=(x436*x450);
evalcond[0]=((((-1.0)*x472))+x470+((x444*x445))+(((-0.433012701892219)*x466))+(((-0.25)*r22))+(((-0.433012701892219)*x451))+(((-1.0)*r22*x458))+((x451*x457))+((x457*x466))+(((-1.0)*x444*x461)));
evalcond[1]=((((-1.0)*x444*x448))+((x440*x457))+(((-0.25)*r12))+(((-0.433012701892219)*x442))+(((-0.433012701892219)*x440))+(((-1.0)*r12*x458))+((x442*x457))+((cj0*x475))+((x444*x463))+((x437*x450)));
evalcond[2]=(((x441*x457))+(((-1.0)*x456*x475))+(((-1.0)*x456*x474))+(((-0.25)*r02))+(((-1.0)*x473))+(((-0.433012701892219)*x441))+(((-1.0)*r02*x458))+((x444*x459))+(((-1.0)*x444*x453))+((x457*x460)));
evalcond[3]=((((-1.0)*cj4*x462))+(((0.125)*x475))+(((0.125)*x474))+(((0.0724249997732329)*x451))+(((0.0724249997732329)*x466))+(((-1.0)*pz))+x462+((x445*x449))+(((-1.0)*x449*x461))+((x439*x451))+(((-0.2828)*x472))+(((0.6)*cj1))+(((0.2828)*x470))+((x439*x466)));
evalcond[4]=((((-1.0)*cj3*x452*x466))+(((-1.0)*r22*sj3*x444))+((cj4*r22*x454))+(((-1.0)*x464*x466))+(((-1.0)*x475))+(((-1.0)*x474))+(((-1.0)*x445*x446))+((cj4*sj5*x443))+(((-1.0)*x438*x469))+((x451*x471))+((x443*x469))+(((-1.0)*r22*x454))+((x461*x476))+(((-0.75)*sj5*x438))+(((-1.0)*sj5*x438*x452)));
evalcond[5]=(((x439*x441))+(((-1.0)*x468*x472))+(((0.0724249997732329)*x441))+(((-1.0)*cj4*x455))+(((0.0724249997732329)*x460))+(((-0.135)*sj0))+(((-0.6)*sj0*sj1))+(((-1.0)*px))+x455+((x449*x459))+(((-1.0)*x465*x474))+(((-1.0)*x465*x475))+(((-1.0)*x449*x453))+((x439*x460))+((x468*x470)));
evalcond[6]=(((x439*x442))+((x439*x440))+(((0.2828)*cj0*x475))+(((0.2828)*x437*x450))+(((0.125)*x477))+(((0.0724249997732329)*x442))+(((0.0724249997732329)*x440))+(((0.6)*x450))+(((-1.0)*py))+(((-0.0245518201972888)*x467))+(((0.0245518201972888)*r12))+(((-1.0)*x448*x449))+((x449*x463))+(((0.135)*cj0))+(((-0.125)*cj0*x470)));
evalcond[7]=(((x453*x476))+(((-1.0)*x441*x464))+(((-1.0)*x459*x476))+(((-1.0)*cj3*x452*x460))+(((-1.0)*x456*x470))+((x441*x471))+(((-1.0)*cj3*x441*x452))+(((-1.0)*x460*x464))+((cj4*r02*x454))+((x460*x471))+(((-1.0)*r02*sj3*x444))+((x446*x453))+(((-1.0)*r02*x454))+(((-1.0)*r00*x446*x447))+((sj0*x472)));
evalcond[8]=(((x446*x448))+(((-1.0)*x440*x464))+((x454*x467))+(((-1.0)*cj3*x440*x452))+((x440*x471))+(((-1.0)*x477))+(((-1.0)*cj3*x442*x452))+((x442*x471))+(((-1.0)*r12*x454))+(((-1.0)*x442*x464))+((x448*x476))+((cj0*x470))+(((-1.0)*r10*x446*x447))+(((-1.0)*r12*sj3*x444))+(((-1.0)*x463*x476)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x478=(r21*sj0);
IkReal x479=((0.5)*sj4);
IkReal x480=(cj4*sj5);
IkReal x481=(r20*sj0);
IkReal x482=((0.866025403784439)*sj4);
IkReal x483=(cj4*cj5);
IkReal x484=((0.433012701892219)*r22*sj0);
CheckValue<IkReal> x485 = IKatan2WithCheck(IkReal((((cj5*x478*x479))+((x478*x480))+(((-1.0)*r22*sj0*x482))+(((-1.0)*x481*x483))+((sj5*x479*x481)))),IkReal(((((-1.0)*x484))+(((-0.25)*x480*x481))+(((-1.0)*cj5*x479*x481))+(((-0.75)*cj5*x478))+((cj4*x484))+((sj5*x478*x479))+(((-0.25)*x478*x483))+(((-0.75)*sj5*x481)))),IKFAST_ATAN2_MAGTHRESH);
if(!x485.valid){
continue;
}
CheckValue<IkReal> x486=IKPowWithIntegerCheck(IKsign((((r00*((((cj5*x482))+(((-0.433012701892219)*sj5))+(((0.433012701892219)*x480))))))+((r02*(((-0.25)+(((-0.75)*cj4))))))+((r01*(((((-1.0)*sj5*x482))+(((-0.433012701892219)*cj5))+(((0.433012701892219)*x483)))))))),-1);
if(!x486.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x485.value)+(((1.5707963267949)*(x486.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x487=IKsin(j3);
IkReal x488=IKcos(j3);
IkReal x489=((0.5)*sj4);
IkReal x490=((1.0)*cj4);
IkReal x491=((0.25)*cj4);
IkReal x492=((0.433012701892219)*x487);
IkReal x493=(cj5*x487);
IkReal x494=(sj5*x487);
IkReal x495=(sj5*x488);
IkReal x496=(cj5*x488);
IkReal x497=((0.866025403784439)*sj4*x488);
evalcond[0]=(((r21*x491*x493))+(((0.75)*r21*x493))+(((-1.0)*r20*x490*x496))+((r20*x489*x495))+((r20*x489*x493))+((r22*x492))+(((0.75)*r20*x494))+(((-1.0)*cj4*r22*x492))+(((-1.0)*r22*x497))+((cj4*r21*x495))+(((-1.0)*r21*x489*x494))+((r21*x489*x496))+((r20*x491*x494)));
evalcond[1]=(((r00*x489*x493))+((r00*x489*x495))+cj0+((r02*x492))+(((-1.0)*r02*x497))+(((-1.0)*r00*x490*x496))+(((-1.0)*r01*x489*x494))+(((0.75)*r00*x494))+(((-1.0)*cj4*r02*x492))+((r00*x491*x494))+((cj4*r01*x495))+((r01*x489*x496))+((r01*x491*x493))+(((0.75)*r01*x493)));
evalcond[2]=((((-1.0)*cj4*r12*x492))+(((0.75)*r10*x494))+sj0+((r11*x489*x496))+((cj4*r11*x495))+((r11*x491*x493))+(((-1.0)*r11*x489*x494))+(((0.75)*r11*x493))+((r10*x491*x494))+((r12*x492))+((r10*x489*x493))+((r10*x489*x495))+(((-1.0)*r12*x497))+(((-1.0)*r10*x490*x496)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[8+1], zeror[8];
int numroots;
IkReal x498=((0.25)*r12);
IkReal x499=((0.0245518201972888)*r22);
IkReal x500=(cj5*r21);
IkReal x501=((0.866025403784439)*sj4);
IkReal x502=(r20*sj5);
IkReal x503=((0.02835)*sj4);
IkReal x504=((0.014175)*cj4);
IkReal x505=((0.433012701892219)*cj5*r11);
IkReal x506=((0.75)*cj4*r12);
IkReal x507=((0.433012701892219)*r10*sj5);
IkReal x508=((0.0724249997732329)*x500);
IkReal x509=((0.0724249997732329)*x502);
IkReal x510=(cj4*x507);
IkReal x511=(cj5*r10*x501);
IkReal x512=(cj4*x505);
IkReal x513=(r11*sj5*x501);
IkReal x514=(x500*x504);
IkReal x515=(x502*x504);
IkReal x516=(cj5*r20*x503);
IkReal x517=(((r21*sj5*x503))+((cj4*x499))+(((1.0)*pz)));
IkReal x518=(x512+x511+x510);
IkReal x519=(x498+x505+x506+x507+x513);
IkReal x520=(x499+x508+x509+x516+x515+x514);
IkReal x521=(cj0+x518+(((-1.0)*x519)));
IkReal x522=(x518+(((-1.0)*x519))+(((-1.0)*cj0)));
IkReal x523=((0.725)+x520+(((-1.0)*x517)));
IkReal x524=((0.475)+x520+(((-1.0)*x517)));
IkReal x525=((-0.725)+x520+(((-1.0)*x517)));
IkReal x526=((-0.475)+x520+(((-1.0)*x517)));
IkReal gconst0=x521;
IkReal gconst1=x522;
IkReal gconst2=x523;
IkReal gconst3=x524;
IkReal gconst4=x521;
IkReal gconst5=x522;
IkReal gconst6=x523;
IkReal gconst7=x524;
IkReal gconst8=x522;
IkReal gconst9=x521;
IkReal gconst10=x525;
IkReal gconst11=x526;
IkReal gconst12=x522;
IkReal gconst13=x521;
IkReal gconst14=x525;
IkReal gconst15=x526;
IkReal x527=cj0*cj0;
IkReal x528=((0.5656)*gconst1);
IkReal x529=(gconst12*gconst7);
IkReal x530=(gconst10*gconst13);
IkReal x531=(gconst0*gconst11);
IkReal x532=(gconst12*gconst15);
IkReal x533=((0.31990336)*gconst9);
IkReal x534=(gconst14*gconst5);
IkReal x535=((0.5656)*gconst9);
IkReal x536=(cj0*gconst9);
IkReal x537=(gconst13*gconst14);
IkReal x538=((0.31990336)*gconst12);
IkReal x539=((0.06990336)*gconst4);
IkReal x540=((2.2624)*cj0);
IkReal x541=(gconst11*gconst12);
IkReal x542=(gconst1*gconst6);
IkReal x543=((0.5656)*gconst8);
IkReal x544=((1.0)*gconst3);
IkReal x545=(gconst5*gconst6);
IkReal x546=(gconst0*gconst3);
IkReal x547=(gconst11*gconst8);
IkReal x548=((1.0)*gconst2);
IkReal x549=(gconst0*gconst4);
IkReal x550=((0.5656)*gconst0);
IkReal x551=(gconst13*gconst6);
IkReal x552=(gconst4*gconst7);
IkReal x553=((2.0)*cj0);
IkReal x554=(gconst11*gconst4);
IkReal x555=(gconst2*gconst5);
IkReal x556=((0.5656)*gconst12);
IkReal x557=(gconst1*gconst14);
IkReal x558=(gconst12*gconst3);
IkReal x559=(gconst3*gconst4);
IkReal x560=((1.27961344)*cj0);
IkReal x561=(gconst1*gconst10);
IkReal x562=(gconst15*gconst4);
IkReal x563=(gconst1*gconst2);
IkReal x564=((16.0)*gconst6);
IkReal x565=((1.1312)*cj0);
IkReal x566=(gconst10*gconst5);
IkReal x567=((0.31990336)*gconst0);
IkReal x568=(gconst2*gconst9);
IkReal x569=((0.06990336)*gconst12);
IkReal x570=((0.31990336)*gconst4);
IkReal x571=(gconst10*gconst9);
IkReal x572=(gconst13*gconst2);
IkReal x573=(gconst12*gconst2);
IkReal x574=((1.0)*gconst9);
IkReal x575=((0.5656)*gconst5);
IkReal x576=(gconst10*gconst12);
IkReal x577=(gconst3*gconst8);
IkReal x578=((0.5656)*gconst4);
IkReal x579=((0.31990336)*gconst1);
IkReal x580=(gconst10*gconst4);
IkReal x581=(gconst2*gconst4);
IkReal x582=((0.5656)*gconst13);
IkReal x583=((0.31990336)*gconst8);
IkReal x584=(gconst12*x535);
IkReal x585=(gconst12*x560);
IkReal x586=(gconst12*x533);
IkReal x587=((1.27961344)*x536);
IkReal x588=(gconst12*x528);
IkReal x589=(gconst4*x535);
IkReal x590=(gconst4*x560);
IkReal x591=(gconst4*x533);
IkReal x592=(gconst1*x538);
IkReal x593=(gconst1*x560);
IkReal x594=(gconst4*x528);
IkReal x595=(gconst1*x570);
IkReal x596=(gconst7*x549);
IkReal x597=(gconst11*x527);
IkReal x598=((9.0496)*x527);
IkReal x599=(x540*x541);
IkReal x600=((2.2624)*gconst14*x536);
IkReal x601=(x540*x558);
IkReal x602=(x540*x557);
IkReal x603=(x540*x554);
IkReal x604=((2.2624)*gconst6*x536);
IkReal x605=(x540*x542);
IkReal x606=(x540*x559);
IkReal x607=((16.0)*gconst14*x527);
IkReal x608=(x592+x591);
IkReal x609=(x588+x589);
IkReal x610=(x599+x600);
IkReal x611=(x606+x605);
IkReal x612=(x603+x602+x601+x604);
op[0]=((((-1.0)*x532*x547))+(((-1.0)*gconst14*x530*x574))+((x537*x547))+(((-1.0)*x586))+((x532*x571)));
op[1]=((((-1.0)*x541*x543))+(((-1.0)*x532*x535))+(((-1.0)*x532*x543))+((x537*x543))+x584+(((-1.0)*x610))+((x535*x537))+((x530*x535))+((x535*x576))+(((-1.0)*gconst11*gconst13*x543)));
op[2]=((((-1.0)*x530*x557))+((x529*x571))+(((-1.0)*gconst8*x538))+((x541*x553))+(((-1.0)*gconst13*x583))+((gconst9*x569))+((x532*x561))+((x532*x568))+(((-1.0)*x529*x547))+(((-1.0)*x531*x532))+((x537*x577))+(((-1.0)*gconst9*x537*x548))+((x531*x537))+((x562*x571))+(((-16.0)*gconst14*x597))+((x547*x551))+(((-1.0)*x547*x562))+(((-1.0)*x534*x571))+x587+(((-1.0)*gconst8*x532*x544))+((x534*x547))+(((-1.0)*x608))+(((-1.0)*x585))+(((-1.0)*gconst6*x530*x574))+(((-1.0)*gconst13*x533))+(((2.0)*gconst14*x536)));
op[3]=((((-1.0)*x543*x562))+((gconst12*x565))+(((9.0496)*x597))+(((-1.0)*gconst11*gconst5*x543))+(((-1.0)*x532*x550))+(((-1.0)*x535*x562))+(((-1.0)*x531*x556))+(((-1.0)*x529*x535))+((x535*x566))+(((-1.0)*x529*x543))+(((-1.0)*x528*x532))+(((-1.0)*x531*x582))+(((-1.1312)*x536))+((x537*x550))+((x534*x535))+(((-1.0)*x612))+(((-1.0)*x543*x558))+(((-1.0)*x543*x554))+x609+x610+((x543*x551))+((x528*x576))+((x534*x543))+((x528*x537))+((x528*x530))+(((-1.0)*x584))+(((-1.0)*gconst13*gconst3*x543))+((x535*x572))+((x535*x573))+((x535*x551))+((x535*x580))+(((-1.0)*gconst14*x598)));
op[4]=((((-1.0)*x534*x561))+(((-1.0)*gconst3*x607))+(((-1.0)*x547*x552))+((x529*x568))+((x529*x561))+((x532*x563))+(((-1.0)*x529*x531))+(((-1.0)*x545*x571))+(((5.11845376)*x527))+(((-1.0)*x564*x597))+((x551*x577))+(((-1.0)*gconst5*x583))+((x562*x568))+((gconst1*x569))+((x531*x534))+((x561*x562))+(((-1.0)*gconst8*x570))+(((-1.0)*x590))+(((-1.0)*x595))+(((-1.0)*gconst9*x534*x548))+((x531*x551))+((x534*x577))+(((-1.0)*x531*x562))+((x537*x546))+(((-1.0)*gconst8*x544*x562))+(((-1.0)*gconst0*x538))+x585+x593+(((-1.0)*gconst1*x537*x548))+((gconst9*x539))+(((-1.0)*gconst13*x567))+(((-1.0)*gconst8*x529*x544))+(((-1.0)*gconst0*x532*x544))+((x552*x571))+(((-1.0)*gconst5*x533))+(((-1.0)*gconst13*x579))+(((-1.0)*gconst9*x548*x551))+(((2.0)*gconst6*x536))+(((-1.0)*x587))+(((-1.0)*x586))+((x553*x558))+((x553*x554))+((x553*x557))+((x545*x547))+(((-1.0)*x530*x542)));
op[5]=(((gconst4*x565))+(((-1.0)*gconst3*gconst5*x543))+((gconst3*x598))+(((-1.0)*x531*x575))+(((-1.0)*x531*x578))+(((-1.0)*gconst1*x565))+((x528*x580))+(((-1.0)*x528*x529))+(((-1.0)*x529*x550))+((x543*x545))+((x528*x566))+((x534*x550))+(((-1.0)*gconst6*x598))+(((-1.0)*x535*x552))+x594+((x550*x551))+(((-1.0)*x611))+(((-0.5656)*gconst15*x549))+(((-1.0)*x543*x559))+(((-1.0)*x543*x552))+x612+((x528*x572))+((x528*x573))+((x535*x545))+(((-1.0)*x546*x582))+(((-1.0)*x609))+((x528*x534))+(((-1.0)*x546*x556))+(((-1.0)*x528*x562))+((x535*x555))+((x528*x551))+((x535*x581)));
op[6]=((((-1.0)*gconst0*x529*x544))+((x542*x553))+(((-1.0)*gconst5*x579))+((x529*x563))+(((-1.0)*gconst13*x542*x548))+(((-0.31990336)*x549))+(((-1.0)*x531*x552))+(((-1.0)*gconst1*x534*x548))+((x545*x577))+(((-1.0)*gconst15*x544*x549))+(((-1.0)*gconst8*x544*x552))+((x562*x563))+(((-1.0)*gconst9*x545*x548))+((x552*x561))+((x552*x568))+(((-1.0)*x542*x566))+((x531*x545))+(((-1.0)*x593))+(((-1.0)*gconst5*x567))+((gconst1*x539))+x590+((x534*x546))+(((-1.0)*x608))+(((-1.0)*gconst3*x527*x564))+((x546*x551))+((x553*x559)));
op[7]=((((-1.0)*x528*x552))+(((-0.5656)*x596))+((x528*x581))+(((-1.0)*x594))+x611+(((-1.0)*x546*x578))+(((-1.0)*x546*x575))+((x545*x550))+((x528*x545))+((x528*x555)));
op[8]=(((x552*x563))+(((-1.0)*x544*x596))+(((-1.0)*x595))+(((-1.0)*gconst5*x542*x548))+((x545*x546)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x613=(sj1*sj5);
IkReal x614=((0.866025403784439)*sj4);
IkReal x615=(cj1*r22);
IkReal x616=(r22*sj1);
IkReal x617=((0.75)*cj4);
IkReal x618=((8.0)*pz);
IkReal x619=(cj4*r20);
IkReal x620=(cj1*r20);
IkReal x621=((0.433012701892219)*sj5);
IkReal x622=((1.50038543842169)*cj4);
IkReal x623=(cj5*sj1);
IkReal x624=((0.433012701892219)*r21);
IkReal x625=((1.73249587352191)*sj4);
IkReal x626=((0.866247936760957)*cj1);
IkReal x627=(cj4*r21);
IkReal x628=(cj1*cj5);
IkReal x629=((1.55904793494682)*r21);
IkReal x630=(cj1*r21*sj5);
if( IKabs(((((0.866247936760957)*x613*x619))+(((-1.55904793494682)*r20*x613))+((x614*x630))+((sj1*x618))+(((0.866247936760957)*x623*x627))+(((-1.0)*cj5*x614*x620))+(((-1.0)*cj4*x624*x628))+(((-1.0)*x623*x629))+(((0.25)*x615))+((r20*x623*x625))+(((-1.0)*r21*x613*x625))+(((-4.8)*cj1*sj1))+(((-1.0)*cj1*x619*x621))+(((-0.762014561578311)*x616))+((x615*x617))+((x624*x628))+(((-1.0)*x616*x622))+((x620*x621)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.433012701892219)*r20*x613))+(((-4.8)*(cj1*cj1)))+(((0.433012701892219)*x613*x619))+((cj4*x623*x624))+(((-1.0)*r21*x613*x614))+(((-1.0)*x628*x629))+(((-1.0)*x623*x624))+((cj5*x626*x627))+((sj5*x619*x626))+(((-0.762014561578311)*x615))+(((-1.55904793494682)*sj5*x620))+((cj1*x618))+(((-0.25)*x616))+(((-1.0)*x625*x630))+((cj5*x620*x625))+(((-1.0)*x615*x622))+(((-1.0)*x616*x617))+((r20*x614*x623)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((0.866247936760957)*x613*x619))+(((-1.55904793494682)*r20*x613))+((x614*x630))+((sj1*x618))+(((0.866247936760957)*x623*x627))+(((-1.0)*cj5*x614*x620))+(((-1.0)*cj4*x624*x628))+(((-1.0)*x623*x629))+(((0.25)*x615))+((r20*x623*x625))+(((-1.0)*r21*x613*x625))+(((-4.8)*cj1*sj1))+(((-1.0)*cj1*x619*x621))+(((-0.762014561578311)*x616))+((x615*x617))+((x624*x628))+(((-1.0)*x616*x622))+((x620*x621))))+IKsqr(((((-0.433012701892219)*r20*x613))+(((-4.8)*(cj1*cj1)))+(((0.433012701892219)*x613*x619))+((cj4*x623*x624))+(((-1.0)*r21*x613*x614))+(((-1.0)*x628*x629))+(((-1.0)*x623*x624))+((cj5*x626*x627))+((sj5*x619*x626))+(((-0.762014561578311)*x615))+(((-1.55904793494682)*sj5*x620))+((cj1*x618))+(((-0.25)*x616))+(((-1.0)*x625*x630))+((cj5*x620*x625))+(((-1.0)*x615*x622))+(((-1.0)*x616*x617))+((r20*x614*x623))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((0.866247936760957)*x613*x619))+(((-1.55904793494682)*r20*x613))+((x614*x630))+((sj1*x618))+(((0.866247936760957)*x623*x627))+(((-1.0)*cj5*x614*x620))+(((-1.0)*cj4*x624*x628))+(((-1.0)*x623*x629))+(((0.25)*x615))+((r20*x623*x625))+(((-1.0)*r21*x613*x625))+(((-4.8)*cj1*sj1))+(((-1.0)*cj1*x619*x621))+(((-0.762014561578311)*x616))+((x615*x617))+((x624*x628))+(((-1.0)*x616*x622))+((x620*x621))), ((((-0.433012701892219)*r20*x613))+(((-4.8)*(cj1*cj1)))+(((0.433012701892219)*x613*x619))+((cj4*x623*x624))+(((-1.0)*r21*x613*x614))+(((-1.0)*x628*x629))+(((-1.0)*x623*x624))+((cj5*x626*x627))+((sj5*x619*x626))+(((-0.762014561578311)*x615))+(((-1.55904793494682)*sj5*x620))+((cj1*x618))+(((-0.25)*x616))+(((-1.0)*x625*x630))+((cj5*x620*x625))+(((-1.0)*x615*x622))+(((-1.0)*x616*x617))+((r20*x614*x623))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x631=IKcos(j2);
IkReal x632=IKsin(j2);
IkReal x633=(cj3*r20);
IkReal x634=((0.014175)*cj4);
IkReal x635=(cj5*r11);
IkReal x636=(r00*sj5);
IkReal x637=(r10*sj5);
IkReal x638=(r21*sj3);
IkReal x639=((0.866025403784439)*sj4);
IkReal x640=(cj5*r20);
IkReal x641=(cj4*sj3);
IkReal x642=((1.0)*cj5);
IkReal x643=(r11*sj5);
IkReal x644=((0.02835)*sj4);
IkReal x645=(cj0*sj1);
IkReal x646=(r20*sj5);
IkReal x647=((0.25)*cj4);
IkReal x648=(r01*sj5);
IkReal x649=((0.433012701892219)*cj3);
IkReal x650=((0.0245518201972888)*r02);
IkReal x651=((1.0)*sj0);
IkReal x652=((0.433012701892219)*cj4);
IkReal x653=((0.75)*cj4);
IkReal x654=(cj5*r00);
IkReal x655=(cj5*r01);
IkReal x656=(r21*sj5);
IkReal x657=((0.0245518201972888)*r22);
IkReal x658=(cj5*r10);
IkReal x659=((0.75)*cj3);
IkReal x660=((0.2828)*sj0);
IkReal x661=(cj5*r21);
IkReal x662=(cj4*r12);
IkReal x663=((0.125)*sj0);
IkReal x664=((0.5)*cj5*sj4);
IkReal x665=(cj1*x632);
IkReal x666=((0.5)*sj3*sj4);
IkReal x667=(sj1*x631);
IkReal x668=((0.433012701892219)*x655);
IkReal x669=(sj1*x632);
IkReal x670=(cj1*x631);
IkReal x671=((0.5)*cj3*sj4);
IkReal x672=(x631*x645);
evalcond[0]=(((x646*x652))+(((-0.433012701892219)*x646))+(((-1.0)*x639*x656))+((x639*x640))+(((-1.0)*r22*x653))+(((-1.0)*x667))+(((-0.433012701892219)*x661))+x665+(((-0.25)*r22))+((x652*x661)));
evalcond[1]=((((-1.0)*r12*x653))+((x635*x652))+((cj0*x670))+(((-0.25)*r12))+((x639*x658))+(((-1.0)*x639*x643))+((x637*x652))+((x632*x645))+(((-0.433012701892219)*x635))+(((-0.433012701892219)*x637)));
evalcond[2]=(((x636*x652))+(((-0.25)*r02))+((x639*x654))+(((-1.0)*x639*x648))+((x652*x655))+(((-1.0)*x651*x670))+(((-1.0)*x668))+(((-1.0)*r02*x653))+(((-0.433012701892219)*x636))+(((-1.0)*x651*x669)));
evalcond[3]=((((-0.2828)*x667))+(((0.0724249997732329)*x646))+((x640*x644))+((x634*x646))+(((-1.0)*pz))+(((0.125)*x670))+(((0.2828)*x665))+((x634*x661))+(((0.125)*x669))+x657+(((-1.0)*x644*x656))+(((0.0724249997732329)*x661))+(((0.6)*cj1))+(((-1.0)*cj4*x657)));
evalcond[4]=((((-1.0)*x659*x661))+(((-1.0)*cj3*x647*x661))+((cj4*r22*x649))+(((-1.0)*x640*x641))+(((-1.0)*r22*x649))+(((-1.0)*sj5*x633*x647))+(((-1.0)*x633*x664))+(((-1.0)*x669))+((cj4*sj5*x638))+(((-1.0)*x670))+((x638*x664))+(((-1.0)*r22*sj3*x639))+((x646*x666))+(((-0.75)*sj5*x633))+((x656*x671)));
evalcond[5]=((((0.0724249997732329)*x636))+((x634*x636))+(((-1.0)*x660*x670))+(((-1.0)*x663*x667))+((x634*x655))+(((-1.0)*x660*x669))+((x663*x665))+((x644*x654))+(((-0.135)*sj0))+(((-0.6)*sj0*sj1))+(((-1.0)*px))+(((0.0724249997732329)*x655))+(((-1.0)*x644*x648))+x650+(((-1.0)*cj4*x650)));
evalcond[6]=((((0.0724249997732329)*x637))+(((0.0724249997732329)*x635))+((x634*x637))+((x634*x635))+(((-0.125)*cj0*x665))+((x644*x658))+(((0.2828)*cj0*x670))+(((0.2828)*x632*x645))+(((0.6)*x645))+(((-1.0)*py))+(((0.125)*x672))+(((0.0245518201972888)*r12))+(((-0.0245518201972888)*x662))+(((-1.0)*x643*x644))+(((0.135)*cj0)));
evalcond[7]=((((-1.0)*cj3*x647*x655))+((sj0*x667))+((cj4*r02*x649))+(((-1.0)*r02*sj3*x639))+(((-1.0)*x654*x671))+(((-1.0)*x655*x659))+(((-1.0)*r00*x641*x642))+(((-1.0)*r02*x649))+((x641*x648))+((x648*x671))+(((-1.0)*x636*x659))+((x636*x666))+((x655*x666))+(((-1.0)*cj3*x636*x647))+(((-1.0)*x651*x665)));
evalcond[8]=(((cj0*x665))+((x635*x666))+(((-1.0)*cj3*x637*x647))+(((-1.0)*r12*sj3*x639))+((x649*x662))+(((-1.0)*r12*x649))+(((-1.0)*x658*x671))+(((-1.0)*cj3*x635*x647))+(((-1.0)*r10*x641*x642))+((x641*x643))+(((-1.0)*x635*x659))+((x643*x671))+(((-1.0)*x672))+((x637*x666))+(((-1.0)*x637*x659)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x673=(cj0*cj5);
IkReal x674=(cj0*r22);
IkReal x675=(cj0*sj5);
IkReal x676=(cj4*r20);
IkReal x677=((0.5)*sj4);
IkReal x678=((0.866025403784439)*sj4);
IkReal x679=((0.433012701892219)*cj5);
IkReal x680=(cj4*r21);
IkReal x681=((0.433012701892219)*sj5);
CheckValue<IkReal> x682=IKPowWithIntegerCheck(IKsign((((r12*(((0.25)+(((0.75)*cj4))))))+((r11*((((sj5*x678))+(((-1.0)*cj4*x679))+x679))))+((r10*(((((-1.0)*cj4*x681))+(((-1.0)*cj5*x678))+x681)))))),-1);
if(!x682.valid){
continue;
}
CheckValue<IkReal> x683 = IKatan2WithCheck(IkReal((((r21*x673*x677))+(((-1.0)*x673*x676))+(((-1.0)*x674*x678))+((x675*x680))+((r20*x675*x677)))),IkReal(((((-1.0)*r20*x673*x677))+(((-0.75)*r20*x675))+((r21*x675*x677))+(((-0.75)*r21*x673))+(((-0.25)*x675*x676))+(((-0.25)*x673*x680))+(((0.433012701892219)*cj4*x674))+(((-0.433012701892219)*x674)))),IKFAST_ATAN2_MAGTHRESH);
if(!x683.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x682.value)))+(x683.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x684=IKsin(j3);
IkReal x685=IKcos(j3);
IkReal x686=((0.5)*sj4);
IkReal x687=((1.0)*cj4);
IkReal x688=((0.25)*cj4);
IkReal x689=((0.433012701892219)*x684);
IkReal x690=(cj5*x684);
IkReal x691=(sj5*x684);
IkReal x692=(sj5*x685);
IkReal x693=(cj5*x685);
IkReal x694=((0.866025403784439)*sj4*x685);
evalcond[0]=(((r22*x689))+((cj4*r21*x692))+(((-1.0)*r21*x686*x691))+(((-1.0)*r20*x687*x693))+((r21*x688*x690))+((r21*x686*x693))+((r20*x686*x692))+((r20*x686*x690))+(((-1.0)*cj4*r22*x689))+(((-1.0)*r22*x694))+((r20*x688*x691))+(((0.75)*r21*x690))+(((0.75)*r20*x691)));
evalcond[1]=(cj0+(((0.75)*r01*x690))+(((-1.0)*r01*x686*x691))+(((0.75)*r00*x691))+((r01*x688*x690))+((r01*x686*x693))+((r00*x686*x690))+((r00*x686*x692))+(((-1.0)*r02*x694))+((r00*x688*x691))+(((-1.0)*r00*x687*x693))+((r02*x689))+(((-1.0)*cj4*r02*x689))+((cj4*r01*x692)));
evalcond[2]=((((-1.0)*r10*x687*x693))+sj0+((r11*x686*x693))+(((0.75)*r11*x690))+(((-1.0)*cj4*r12*x689))+(((-1.0)*r12*x694))+((r10*x688*x691))+((cj4*r11*x692))+((r11*x688*x690))+((r12*x689))+(((-1.0)*r11*x686*x691))+(((0.75)*r10*x691))+((r10*x686*x690))+((r10*x686*x692)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[8+1], zeror[8];
int numroots;
IkReal x695=((0.25)*r12);
IkReal x696=((0.0245518201972888)*r22);
IkReal x697=(cj5*r21);
IkReal x698=((0.866025403784439)*sj4);
IkReal x699=(r20*sj5);
IkReal x700=((0.02835)*sj4);
IkReal x701=((0.014175)*cj4);
IkReal x702=((0.433012701892219)*cj5*r11);
IkReal x703=((0.75)*cj4*r12);
IkReal x704=((0.433012701892219)*r10*sj5);
IkReal x705=((0.0724249997732329)*x697);
IkReal x706=((0.0724249997732329)*x699);
IkReal x707=(cj4*x704);
IkReal x708=(cj5*r10*x698);
IkReal x709=(cj4*x702);
IkReal x710=(r11*sj5*x698);
IkReal x711=(x697*x701);
IkReal x712=(x699*x701);
IkReal x713=(cj5*r20*x700);
IkReal x714=(((cj4*x696))+((r21*sj5*x700))+(((1.0)*pz)));
IkReal x715=(x708+x709+x707);
IkReal x716=(x695+x710+x702+x703+x704);
IkReal x717=(x696+x711+x713+x712+x706+x705);
IkReal x718=(cj0+(((-1.0)*x716))+x715);
IkReal x719=((((-1.0)*x716))+x715+(((-1.0)*cj0)));
IkReal x720=((0.725)+(((-1.0)*x714))+x717);
IkReal x721=((0.475)+(((-1.0)*x714))+x717);
IkReal x722=((-0.725)+(((-1.0)*x714))+x717);
IkReal x723=((-0.475)+(((-1.0)*x714))+x717);
IkReal gconst0=x718;
IkReal gconst1=x719;
IkReal gconst2=x720;
IkReal gconst3=x721;
IkReal gconst4=x718;
IkReal gconst5=x719;
IkReal gconst6=x720;
IkReal gconst7=x721;
IkReal gconst8=x719;
IkReal gconst9=x718;
IkReal gconst10=x722;
IkReal gconst11=x723;
IkReal gconst12=x719;
IkReal gconst13=x718;
IkReal gconst14=x722;
IkReal gconst15=x723;
IkReal x724=cj0*cj0;
IkReal x725=((0.5656)*gconst1);
IkReal x726=(gconst12*gconst7);
IkReal x727=(gconst10*gconst13);
IkReal x728=(gconst0*gconst11);
IkReal x729=(gconst12*gconst15);
IkReal x730=((0.31990336)*gconst9);
IkReal x731=(gconst14*gconst5);
IkReal x732=((0.5656)*gconst9);
IkReal x733=(cj0*gconst9);
IkReal x734=(gconst13*gconst14);
IkReal x735=((0.31990336)*gconst12);
IkReal x736=((0.06990336)*gconst4);
IkReal x737=((2.2624)*cj0);
IkReal x738=(gconst11*gconst12);
IkReal x739=(gconst1*gconst6);
IkReal x740=((0.5656)*gconst8);
IkReal x741=((1.0)*gconst3);
IkReal x742=(gconst5*gconst6);
IkReal x743=(gconst0*gconst3);
IkReal x744=(gconst11*gconst8);
IkReal x745=((1.0)*gconst2);
IkReal x746=(gconst0*gconst4);
IkReal x747=((0.5656)*gconst0);
IkReal x748=(gconst13*gconst6);
IkReal x749=(gconst4*gconst7);
IkReal x750=((2.0)*cj0);
IkReal x751=(gconst11*gconst4);
IkReal x752=(gconst2*gconst5);
IkReal x753=((0.5656)*gconst12);
IkReal x754=(gconst1*gconst14);
IkReal x755=(gconst12*gconst3);
IkReal x756=(gconst3*gconst4);
IkReal x757=((1.27961344)*cj0);
IkReal x758=(gconst1*gconst10);
IkReal x759=(gconst15*gconst4);
IkReal x760=(gconst1*gconst2);
IkReal x761=((16.0)*gconst6);
IkReal x762=((1.1312)*cj0);
IkReal x763=(gconst10*gconst5);
IkReal x764=((0.31990336)*gconst0);
IkReal x765=(gconst2*gconst9);
IkReal x766=((0.06990336)*gconst12);
IkReal x767=((0.31990336)*gconst4);
IkReal x768=(gconst10*gconst9);
IkReal x769=(gconst13*gconst2);
IkReal x770=(gconst12*gconst2);
IkReal x771=((1.0)*gconst9);
IkReal x772=((0.5656)*gconst5);
IkReal x773=(gconst10*gconst12);
IkReal x774=(gconst3*gconst8);
IkReal x775=((0.5656)*gconst4);
IkReal x776=((0.31990336)*gconst1);
IkReal x777=(gconst10*gconst4);
IkReal x778=(gconst2*gconst4);
IkReal x779=((0.5656)*gconst13);
IkReal x780=((0.31990336)*gconst8);
IkReal x781=(gconst12*x732);
IkReal x782=(gconst12*x757);
IkReal x783=(gconst12*x730);
IkReal x784=((1.27961344)*x733);
IkReal x785=(gconst12*x725);
IkReal x786=(gconst4*x732);
IkReal x787=(gconst4*x757);
IkReal x788=(gconst4*x730);
IkReal x789=(gconst1*x735);
IkReal x790=(gconst1*x757);
IkReal x791=(gconst4*x725);
IkReal x792=(gconst1*x767);
IkReal x793=(gconst7*x746);
IkReal x794=(gconst11*x724);
IkReal x795=((9.0496)*x724);
IkReal x796=(x737*x738);
IkReal x797=((2.2624)*gconst14*x733);
IkReal x798=(x737*x755);
IkReal x799=(x737*x754);
IkReal x800=(x737*x751);
IkReal x801=((2.2624)*gconst6*x733);
IkReal x802=(x737*x739);
IkReal x803=(x737*x756);
IkReal x804=((16.0)*gconst14*x724);
IkReal x805=(x788+x789);
IkReal x806=(x786+x785);
IkReal x807=(x797+x796);
IkReal x808=(x803+x802);
IkReal x809=(x799+x798+x801+x800);
op[0]=(((x734*x744))+(((-1.0)*gconst14*x727*x771))+(((-1.0)*x783))+(((-1.0)*x729*x744))+((x729*x768)));
op[1]=(((x734*x740))+((x727*x732))+(((-1.0)*x729*x740))+(((-1.0)*gconst11*gconst13*x740))+(((-1.0)*x738*x740))+((x732*x773))+x781+(((-1.0)*x807))+((x732*x734))+(((-1.0)*x729*x732)));
op[2]=((((-1.0)*gconst13*x730))+(((-1.0)*x731*x768))+(((-1.0)*gconst8*x735))+((x728*x734))+(((-1.0)*x782))+(((-16.0)*gconst14*x794))+((x744*x748))+(((-1.0)*gconst6*x727*x771))+((x738*x750))+((x731*x744))+(((-1.0)*x728*x729))+((x759*x768))+(((-1.0)*x726*x744))+(((-1.0)*x727*x754))+((x729*x758))+((x726*x768))+x784+(((-1.0)*gconst8*x729*x741))+(((-1.0)*x805))+((gconst9*x766))+(((-1.0)*gconst13*x780))+(((-1.0)*gconst9*x734*x745))+((x729*x765))+(((-1.0)*x744*x759))+(((2.0)*gconst14*x733))+((x734*x774)));
op[3]=((((-1.1312)*x733))+((x734*x747))+((x731*x732))+(((-1.0)*x781))+(((-1.0)*gconst13*gconst3*x740))+(((-1.0)*x729*x747))+(((-1.0)*x728*x779))+((x731*x740))+(((-1.0)*x728*x753))+((x725*x773))+((x740*x748))+(((-1.0)*x725*x729))+((gconst12*x762))+(((-1.0)*x726*x740))+((x732*x770))+((x732*x777))+((x732*x748))+(((-1.0)*x732*x759))+((x725*x727))+((x725*x734))+x807+x806+((x732*x763))+((x732*x769))+(((-1.0)*x726*x732))+(((-1.0)*x809))+(((9.0496)*x794))+(((-1.0)*gconst14*x795))+(((-1.0)*x740*x759))+(((-1.0)*x740*x755))+(((-1.0)*x740*x751))+(((-1.0)*gconst11*gconst5*x740)));
op[4]=((((-1.0)*gconst5*x730))+((x734*x743))+((x748*x774))+(((2.0)*gconst6*x733))+(((-1.0)*gconst8*x767))+((x742*x744))+(((-1.0)*x761*x794))+(((-1.0)*x744*x749))+(((-1.0)*x792))+((x728*x731))+(((-1.0)*x731*x758))+(((-1.0)*x742*x768))+(((-1.0)*gconst9*x745*x748))+(((-1.0)*gconst5*x780))+(((-1.0)*x784))+(((-1.0)*x787))+(((-1.0)*x783))+((x758*x759))+((x759*x765))+((gconst9*x736))+((x731*x774))+(((-1.0)*gconst8*x726*x741))+(((-1.0)*gconst0*x735))+(((-1.0)*gconst1*x734*x745))+(((-1.0)*gconst0*x729*x741))+(((-1.0)*gconst8*x741*x759))+((x726*x765))+x790+x782+(((-1.0)*gconst13*x776))+(((-1.0)*x727*x739))+(((-1.0)*x726*x728))+(((5.11845376)*x724))+(((-1.0)*x728*x759))+((x750*x751))+((x750*x755))+((x750*x754))+((x726*x758))+(((-1.0)*gconst3*x804))+((x728*x748))+((gconst1*x766))+((x729*x760))+((x749*x768))+(((-1.0)*gconst9*x731*x745))+(((-1.0)*gconst13*x764)));
op[5]=((((-0.5656)*gconst15*x746))+(((-1.0)*gconst1*x762))+(((-1.0)*x728*x772))+(((-1.0)*x728*x775))+((x725*x769))+((x725*x763))+((x747*x748))+((x731*x747))+((x725*x770))+((x725*x777))+(((-1.0)*x732*x749))+((gconst3*x795))+(((-1.0)*gconst6*x795))+((x740*x742))+((x725*x748))+(((-1.0)*x725*x726))+(((-1.0)*x726*x747))+((x732*x778))+((x732*x742))+(((-1.0)*x725*x759))+((x732*x752))+(((-1.0)*x740*x749))+(((-1.0)*x743*x753))+x791+((x725*x731))+x809+(((-1.0)*x808))+(((-1.0)*x806))+(((-1.0)*gconst3*gconst5*x740))+(((-1.0)*x743*x779))+((gconst4*x762))+(((-1.0)*x740*x756)));
op[6]=(((x742*x774))+(((-1.0)*gconst3*x724*x761))+((x739*x750))+(((-1.0)*x790))+(((-0.31990336)*x746))+((gconst1*x736))+(((-1.0)*gconst5*x776))+(((-1.0)*gconst9*x742*x745))+(((-1.0)*gconst13*x739*x745))+(((-1.0)*gconst5*x764))+((x731*x743))+((x759*x760))+(((-1.0)*gconst15*x741*x746))+(((-1.0)*gconst0*x726*x741))+(((-1.0)*x739*x763))+(((-1.0)*gconst1*x731*x745))+((x743*x748))+((x726*x760))+x787+(((-1.0)*x728*x749))+(((-1.0)*x805))+((x749*x758))+((x750*x756))+((x728*x742))+(((-1.0)*gconst8*x741*x749))+((x749*x765)));
op[7]=(((x742*x747))+(((-1.0)*x791))+((x725*x752))+((x725*x778))+((x725*x742))+(((-1.0)*x725*x749))+x808+(((-1.0)*x743*x772))+(((-1.0)*x743*x775))+(((-0.5656)*x793)));
op[8]=((((-1.0)*x741*x793))+((x742*x743))+(((-1.0)*x792))+(((-1.0)*gconst5*x739*x745))+((x749*x760)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x810=(sj1*sj5);
IkReal x811=((0.866025403784439)*sj4);
IkReal x812=(cj1*r22);
IkReal x813=(r22*sj1);
IkReal x814=((0.75)*cj4);
IkReal x815=((8.0)*pz);
IkReal x816=(cj4*r20);
IkReal x817=(cj1*r20);
IkReal x818=((0.433012701892219)*sj5);
IkReal x819=((1.50038543842169)*cj4);
IkReal x820=(cj5*sj1);
IkReal x821=((0.433012701892219)*r21);
IkReal x822=((1.73249587352191)*sj4);
IkReal x823=((0.866247936760957)*cj1);
IkReal x824=(cj4*r21);
IkReal x825=(cj1*cj5);
IkReal x826=((1.55904793494682)*r21);
IkReal x827=(cj1*r21*sj5);
if( IKabs(((((0.25)*x812))+(((0.866247936760957)*x820*x824))+((sj1*x815))+((x821*x825))+((x812*x814))+(((-1.0)*cj5*x811*x817))+((x811*x827))+(((-1.55904793494682)*r20*x810))+((x817*x818))+(((-4.8)*cj1*sj1))+(((-1.0)*r21*x810*x822))+(((-1.0)*x813*x819))+(((0.866247936760957)*x810*x816))+(((-1.0)*x820*x826))+((r20*x820*x822))+(((-0.762014561578311)*x813))+(((-1.0)*cj1*x816*x818))+(((-1.0)*cj4*x821*x825)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x812*x819))+((r20*x811*x820))+(((-4.8)*(cj1*cj1)))+(((-1.0)*x822*x827))+(((-0.25)*x813))+(((-1.0)*r21*x810*x811))+(((0.433012701892219)*x810*x816))+((sj5*x816*x823))+(((-1.55904793494682)*sj5*x817))+(((-1.0)*x813*x814))+(((-1.0)*x820*x821))+((cj1*x815))+((cj5*x817*x822))+(((-0.762014561578311)*x812))+((cj5*x823*x824))+(((-1.0)*x825*x826))+((cj4*x820*x821))+(((-0.433012701892219)*r20*x810)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((0.25)*x812))+(((0.866247936760957)*x820*x824))+((sj1*x815))+((x821*x825))+((x812*x814))+(((-1.0)*cj5*x811*x817))+((x811*x827))+(((-1.55904793494682)*r20*x810))+((x817*x818))+(((-4.8)*cj1*sj1))+(((-1.0)*r21*x810*x822))+(((-1.0)*x813*x819))+(((0.866247936760957)*x810*x816))+(((-1.0)*x820*x826))+((r20*x820*x822))+(((-0.762014561578311)*x813))+(((-1.0)*cj1*x816*x818))+(((-1.0)*cj4*x821*x825))))+IKsqr(((((-1.0)*x812*x819))+((r20*x811*x820))+(((-4.8)*(cj1*cj1)))+(((-1.0)*x822*x827))+(((-0.25)*x813))+(((-1.0)*r21*x810*x811))+(((0.433012701892219)*x810*x816))+((sj5*x816*x823))+(((-1.55904793494682)*sj5*x817))+(((-1.0)*x813*x814))+(((-1.0)*x820*x821))+((cj1*x815))+((cj5*x817*x822))+(((-0.762014561578311)*x812))+((cj5*x823*x824))+(((-1.0)*x825*x826))+((cj4*x820*x821))+(((-0.433012701892219)*r20*x810))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((0.25)*x812))+(((0.866247936760957)*x820*x824))+((sj1*x815))+((x821*x825))+((x812*x814))+(((-1.0)*cj5*x811*x817))+((x811*x827))+(((-1.55904793494682)*r20*x810))+((x817*x818))+(((-4.8)*cj1*sj1))+(((-1.0)*r21*x810*x822))+(((-1.0)*x813*x819))+(((0.866247936760957)*x810*x816))+(((-1.0)*x820*x826))+((r20*x820*x822))+(((-0.762014561578311)*x813))+(((-1.0)*cj1*x816*x818))+(((-1.0)*cj4*x821*x825))), ((((-1.0)*x812*x819))+((r20*x811*x820))+(((-4.8)*(cj1*cj1)))+(((-1.0)*x822*x827))+(((-0.25)*x813))+(((-1.0)*r21*x810*x811))+(((0.433012701892219)*x810*x816))+((sj5*x816*x823))+(((-1.55904793494682)*sj5*x817))+(((-1.0)*x813*x814))+(((-1.0)*x820*x821))+((cj1*x815))+((cj5*x817*x822))+(((-0.762014561578311)*x812))+((cj5*x823*x824))+(((-1.0)*x825*x826))+((cj4*x820*x821))+(((-0.433012701892219)*r20*x810))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x828=IKcos(j2);
IkReal x829=IKsin(j2);
IkReal x830=(cj3*r20);
IkReal x831=((0.014175)*cj4);
IkReal x832=(cj5*r11);
IkReal x833=(r00*sj5);
IkReal x834=(r10*sj5);
IkReal x835=(r21*sj3);
IkReal x836=((0.866025403784439)*sj4);
IkReal x837=(cj5*r20);
IkReal x838=(cj4*sj3);
IkReal x839=((1.0)*cj5);
IkReal x840=(r11*sj5);
IkReal x841=((0.02835)*sj4);
IkReal x842=(cj0*sj1);
IkReal x843=(r20*sj5);
IkReal x844=((0.25)*cj4);
IkReal x845=(r01*sj5);
IkReal x846=((0.433012701892219)*cj3);
IkReal x847=((0.0245518201972888)*r02);
IkReal x848=((1.0)*sj0);
IkReal x849=((0.433012701892219)*cj4);
IkReal x850=((0.75)*cj4);
IkReal x851=(cj5*r00);
IkReal x852=(cj5*r01);
IkReal x853=(r21*sj5);
IkReal x854=((0.0245518201972888)*r22);
IkReal x855=(cj5*r10);
IkReal x856=((0.75)*cj3);
IkReal x857=((0.2828)*sj0);
IkReal x858=(cj5*r21);
IkReal x859=(cj4*r12);
IkReal x860=((0.125)*sj0);
IkReal x861=((0.5)*cj5*sj4);
IkReal x862=(cj1*x829);
IkReal x863=((0.5)*sj3*sj4);
IkReal x864=(sj1*x828);
IkReal x865=((0.433012701892219)*x852);
IkReal x866=(sj1*x829);
IkReal x867=(cj1*x828);
IkReal x868=((0.5)*cj3*sj4);
IkReal x869=(x828*x842);
evalcond[0]=((((-0.433012701892219)*x858))+(((-1.0)*r22*x850))+(((-1.0)*x864))+((x843*x849))+((x836*x837))+(((-0.433012701892219)*x843))+(((-1.0)*x836*x853))+(((-0.25)*r22))+x862+((x849*x858)));
evalcond[1]=(((cj0*x867))+(((-1.0)*r12*x850))+(((-0.25)*r12))+(((-1.0)*x836*x840))+((x832*x849))+((x829*x842))+(((-0.433012701892219)*x832))+(((-0.433012701892219)*x834))+((x834*x849))+((x836*x855)));
evalcond[2]=((((-1.0)*x865))+(((-1.0)*x836*x845))+(((-1.0)*x848*x867))+(((-1.0)*x848*x866))+(((-0.25)*r02))+((x833*x849))+(((-1.0)*r02*x850))+(((-0.433012701892219)*x833))+((x849*x852))+((x836*x851)));
evalcond[3]=((((0.0724249997732329)*x843))+((x837*x841))+(((0.2828)*x862))+(((-1.0)*pz))+(((-1.0)*x841*x853))+((x831*x858))+(((0.125)*x866))+(((0.125)*x867))+x854+(((0.6)*cj1))+(((0.0724249997732329)*x858))+(((-1.0)*cj4*x854))+(((-0.2828)*x864))+((x831*x843)));
evalcond[4]=((((-1.0)*x830*x861))+(((-0.75)*sj5*x830))+((cj4*r22*x846))+((cj4*sj5*x835))+(((-1.0)*sj5*x830*x844))+(((-1.0)*x866))+(((-1.0)*x867))+(((-1.0)*x837*x838))+((x835*x861))+((x853*x868))+((x843*x863))+(((-1.0)*r22*x846))+(((-1.0)*x856*x858))+(((-1.0)*cj3*x844*x858))+(((-1.0)*r22*sj3*x836)));
evalcond[5]=(((x831*x833))+(((-1.0)*x841*x845))+(((0.0724249997732329)*x833))+(((-1.0)*cj4*x847))+(((-1.0)*x860*x864))+(((-0.135)*sj0))+(((-0.6)*sj0*sj1))+(((-1.0)*px))+((x841*x851))+((x831*x852))+((x860*x862))+x847+(((0.0724249997732329)*x852))+(((-1.0)*x857*x866))+(((-1.0)*x857*x867)));
evalcond[6]=((((-0.125)*cj0*x862))+((x831*x834))+((x831*x832))+(((-0.0245518201972888)*x859))+(((0.6)*x842))+(((0.0724249997732329)*x832))+(((0.0724249997732329)*x834))+(((-1.0)*x840*x841))+(((0.2828)*x829*x842))+(((0.2828)*cj0*x867))+(((-1.0)*py))+((x841*x855))+(((0.0245518201972888)*r12))+(((0.125)*x869))+(((0.135)*cj0)));
evalcond[7]=((((-1.0)*r02*x846))+((x838*x845))+((x845*x868))+(((-1.0)*cj3*x833*x844))+(((-1.0)*x852*x856))+(((-1.0)*x848*x862))+((sj0*x864))+(((-1.0)*x851*x868))+(((-1.0)*x833*x856))+((cj4*r02*x846))+(((-1.0)*r00*x838*x839))+((x833*x863))+((x852*x863))+(((-1.0)*cj3*x844*x852))+(((-1.0)*r02*sj3*x836)));
evalcond[8]=(((cj0*x862))+((x838*x840))+(((-1.0)*r10*x838*x839))+(((-1.0)*cj3*x832*x844))+(((-1.0)*x834*x856))+(((-1.0)*x869))+((x834*x863))+(((-1.0)*x832*x856))+(((-1.0)*r12*sj3*x836))+((x846*x859))+(((-1.0)*r12*x846))+(((-1.0)*cj3*x834*x844))+((x832*x863))+((x840*x868))+(((-1.0)*x855*x868)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}
}
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly12qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[24*24]) = {0};
    IkReal IKFAST_ALIGNED16(A[12*12]);
    IkReal IKFAST_ALIGNED16(work[24*24*23]);
    int ipiv[12];
    int info, coeffindex;
    const int worksize=24*24*23;
    const int matrixdim = 12;
    const int matrixdim2 = 24;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 6; ++j) {
        for(int k = 0; k < 9; ++k) {
            M[matrixdim+(j+6)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+3)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 6; ++j) {
        for(int k = 0; k < 9; ++k) {
            M[matrixdim+(j+6)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+3)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 6; ++j) {
        for(int k = 0; k < 9; ++k) {
            A[(j+6)+matrixdim*k] = A[j+matrixdim*(k+3)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 3; ++k) {
            A[j+matrixdim*k] = A[(j+6)+matrixdim*(k+9)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 6; ++j) {
            for(int k = 0; k < 9; ++k) {
                IkReal a = matcoeffs[coeffindex+108], b = matcoeffs[coeffindex+54], c = matcoeffs[coeffindex];
                A[(j+6)+matrixdim*k] = A[j+matrixdim*(k+3)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+6)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+3)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+6)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+3)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 3; ++k) {
                A[j+matrixdim*k] = A[(j+6)+matrixdim*(k+9)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[24]);
    IkReal IKFAST_ALIGNED16(wi[24]);
    IkReal IKFAST_ALIGNED16(vr[24*24]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        if( IKabs(wi[i]) < tol*100 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency12(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[3]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[5]/ev[2];
                    rawroots[numroots++] = ev[2]/ev[1];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[9]/ev[6];
                    rawroots[numroots++] = ev[10]/ev[9];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[11]/ev[8];
                    rawroots[numroots++] = ev[11]/ev[10];
                }
            }
        }
    }
}static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+6, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+8, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
extern "C" IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - KJ125 (def65fffe4ce3243af35d1e6c66fb121)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004b"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
