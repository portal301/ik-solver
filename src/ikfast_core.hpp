// ikfast_core.hpp
#pragma once

#include <string>
#include <vector>
#include <map>
#include <array>


namespace ikcore {

using IkReal = double;

struct IkSolutionData {
    std::vector<IkReal> joints;  /// 하나의 해
};

// Joint limit pair: [lower, upper] in radians
struct JointLimit {
    IkReal lower;
    IkReal upper;
};

// Robot joint limits loaded from JSON
struct RobotJointLimits {
    std::string robot_name;
    int num_joints;
    std::vector<JointLimit> limits;  // [num_joints]
};

struct Transform {
    std::array<IkReal, 12> data{};
    Transform() = default;
    explicit Transform(const IkReal* ptr) {
        std::copy_n(ptr, 12, data.begin());
    }
    IkReal& operator[](size_t index) {
        return data.at(index);
    }
    const IkReal& operator[](size_t index) const {
        return data.at(index);
    }
};


// Configuration enum for pose filtering
enum class PoseConfig {
    NULL_CONFIG = -1,         // Invalid/undefined configuration
    FRONT = 0,                // Shoulder: front side
    BACK = 1,                 // Shoulder: BACK side
    UP = 2,                   // Elbow: up
    DOWN = 3,                 // Elbow: down
    N_FLIP = 4,               // Wrist: no flip
    FLIP = 5                  // Wrist: flip
};

// BEGIN AUTO-GENERATED JOINT LIMITS - DO NOT EDIT MANUALLY
// This section is automatically generated by run_all_robots.py
// Data source: URDF files in robots/ directory
namespace joint_limits_data {

// Joint limits loaded from URDF files at build time
inline const std::map<std::string, std::vector<JointLimit>> ROBOT_JOINT_LIMITS = {
    {"GP10", {
        {-3.141590, 3.141590},
        {-1.745330, 2.530730},
        {-1.221730, 3.316130},
        {-3.316130, 3.316130},
        {-0.785400, 3.926990},
        {-6.283190, 6.283190},
    }},
    {"GP12", {
        {-2.967060, 2.967060},
        {-1.570800, 2.705260},
        {-1.483530, 2.705260},
        {-3.490660, 3.490660},
        {-2.617990, 2.617990},
        {-7.941250, 7.941250},
    }},
    {"GP25", {
        {-3.141590, 3.141590},
        {-1.832600, 2.705260},
        {-1.500980, 2.792530},
        {-3.490660, 3.490660},
        {-2.617990, 2.617990},
        {-7.941250, 7.941250},
    }},
    {"GP25-12", {
        {-3.141590, 3.141590},
        {-1.832600, 2.705260},
        {-1.500980, 2.792530},
        {-3.490660, 3.490660},
        {-2.617990, 2.617990},
        {-7.941250, 7.941250},
    }},
    {"GP4", {
        {-2.967060, 2.967060},
        {-1.919860, 2.268930},
        {-1.134460, 3.490660},
        {-3.490660, 3.490660},
        {-2.146750, 2.146750},
        {-7.941250, 7.941250},
    }},
    {"GP50", {
        {-3.141590, 3.141590},
        {-1.570800, 2.356190},
        {-1.396260, 3.595380},
        {-6.283190, 6.283190},
        {-2.181660, 2.181660},
        {-6.283190, 6.283190},
    }},
    {"GP7", {
        {-2.967060, 2.967060},
        {-1.134460, 2.530730},
        {-1.221730, 3.316130},
        {-3.316130, 3.316130},
        {-2.356190, 2.356190},
        {-6.283190, 6.283190},
    }},
    {"GP8", {
        {-2.967060, 2.967060},
        {-1.134460, 2.530730},
        {-1.221730, 3.316130},
        {-3.316130, 3.316130},
        {-2.356190, 2.356190},
        {-6.283190, 6.283190},
    }},
    {"GP8L", {
        {-2.967060, 2.967060},
        {-1.570800, 2.617990},
        {-1.483530, 2.617990},
        {-3.490660, 3.490660},
        {-2.356190, 2.356190},
        {-6.283190, 6.283190},
    }},
    {"KJ125", {
        {-2.792530, 2.792530},
        {-1.396260, 2.268930},
        {-1.309000, 1.570800},
        {-12.566370, 12.566370},
        {-12.566370, 12.566370},
        {-7.155850, 7.155850},
    }},
    {"MPX3500-C00X", {
        {-2.617990, 2.617990},
        {-1.134460, 2.443460},
        {-1.134460, 1.570800},
        {-12.566370, 12.566370},
        {-12.566370, 12.566370},
        {-12.566370, 12.566370},
    }},
    {"MPX3500-C10X", {
        {-2.617990, 2.617990},
        {-1.134460, 2.443460},
        {-1.134460, 1.570800},
        {-12.566370, 12.566370},
        {-12.566370, 12.566370},
        {-12.566370, 12.566370},
    }},
    {"RS007L", {
        {-3.141590, 3.141590},
        {-2.356190, 2.356190},
        {-2.740170, 2.740170},
        {-3.490660, 3.490660},
        {-2.181660, 2.181660},
        {-6.283190, 6.283190},
    }},
    {"untitled", {
        {-2.356190, 2.356190},
        {-2.740170, 2.740170},
        {-3.490660, 3.490660},
        {-2.181660, 2.181660},
        {-2.181660, 2.181660},
        {-6.283190, 6.283190},
    }},
};

}  // namespace joint_limits_data
// END AUTO-GENERATED JOINT LIMITS








// BEGIN AUTO-GENERATED COORDINATE TRANSFORMS - DO NOT EDIT MANUALLY
// This section is automatically generated by scripts/generate_coordinate_transforms.py
// Data source: configs/manufacturer_settings.json
namespace coordinate_transform_data {

// Coordinate transforms for manufacturer-specific base-to-tool frame conversions
// Each transform is a 4x4 matrix stored as 12 elements (first 3 rows, row-major):
// [R11, R12, R13, Tx, R21, R22, R23, Ty, R31, R32, R33, Tz]
inline const std::map<std::string, std::array<IkReal, 12>> MANUFACTURER_TRANSFORMS = {
    {"kawasaki", {
         1.000000000000000,  // R11
        -0.000000000000000,  // R12
         0.000000000000000,  // R13
         0.000000000000000,  // Tx
         0.000000000000000,  // R21
         0.000000000000000,  // R22
         1.000000000000000,  // R23
         0.000000000000000,  // Ty
        -0.000000000000000,  // R31
        -1.000000000000000,  // R32
         0.000000000000000,  // R33
         0.000000000000000,  // Tz,
    }},
};

}  // namespace coordinate_transform_data
// END AUTO-GENERATED COORDINATE TRANSFORMS








// Configuration constants for solution filtering
// Shoulder/Front-Back: 0 = FRONT, 1 = REAR
// Elbow/Up-Down:       2 = UP,    3 = DOWN
// Wrist/Flip:          4 = N_FLIP, 5 = FLIP
//
// NOTE: Using int instead of enum to avoid casting issues in Python binding

bool load_ik_plugins(const std::string& robots_dir);

// Inverse Kinematics - Returns ALL solutions
// TCP pose: 4x4 transformation matrix (row-major, first 3 rows only)
bool solveIK(
    const std::string& robot_name,
    const IkReal* tcp_pose,        // [12]: R11, R12, R13, Tx, R21, R22, R23, Ty, R31, R32, R33, Tz
    std::vector<IkSolutionData>& out_solutions
);

int get_num_joints(const std::string& robot_name);
int get_num_free_parameters(const std::string& robot_name);

// Helper: Detect manufacturer from robot name
std::string detect_manufacturer(const std::string& robot_name);

// Forward Kinematics
bool computeFK(
    const std::string& robot_name,
    const IkReal* joints,     // [num_joints]
    IkReal* eetrans,          // [3] output position
    IkReal* eerot             // [9] output rotation matrix (row-major)
);

// Configuration-based IK solver
// Returns single solution matching the configuration
bool solveIKWithConfig(
    const std::string& robot_name,
    const IkReal* tcp_pose,        // [12]: R11, R12, R13, Tx, R21, R22, R23, Ty, R31, R32, R33, Tz
    int shoulder_config,           // 0 = FRONT, 1 = REAR
    int elbow_config,              // 2 = UP, 3 = DOWN
    int wrist_config,              // 4 = N_FLIP, 5 = FLIP
    IkReal* out_joints,            // [num_joints] output
    bool* out_is_solvable,
    const IkReal* current_joints = nullptr  // [num_joints] optional: for continuity
);

// Joint-based IK solver
// Returns single solution nearest to current_joints
bool solveIKWithJoint(
    const std::string& robot_name,
    const IkReal* tcp_pose,        // [12]: R11, R12, R13, Tx, R21, R22, R23, Ty, R31, R32, R33, Tz
    const IkReal* current_joints,  // [num_joints] current state
    IkReal* out_joints,            // [num_joints] output
    bool* out_is_solvable
);

// Retrieve joint limits from compiled data.
// Returns true if limits were found for the robot.
bool get_joint_limits(const std::string& robot_name, std::vector<JointLimit>& out_limits);

} // namespace ikcore
